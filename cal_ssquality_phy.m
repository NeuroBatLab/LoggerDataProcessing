function cal_ssquality_phy(InputPath, OutputPath)
% this function expect that the original CSC files are sitting in
% 'extracted_data' folder at the same level as InputPath
addpath(genpath('/Users/elie/Documents/CODE/Kilosort2_Tetrode'))
addpath(genpath('/Users/elie/Documents/CODE/npy-matlab'))

%% Massage input
%Hard coded input:
TimeStep = 20*60*10^6;% Time Step of 30 min for the calculation of the time varying spike sorting quality measures
DebugFig = 1; % Set to 1 to see figures of spike sorting quality.
Num_EperBundle = 4;

% Deal with input variables
if nargin<1
    error('please provide the path to the files containing\nthe snippets and spike arrival time generated by Phy\n');
end

% Get the folder containing the raw data as extracted by extract_logger_data.m
[Root,~]=fileparts(InputPath);
Data_folder = fullfile(Root, 'extracted_data');

if nargin<2
    OutputPath = Data_folder;
    fprintf(1, 'No outputpath indicated, data will be saved under the raw data folder:\n%s\n', OutputPath);
else
    fprintf(1, 'Converted files will be saved under:\n%s\n', OutputPath);
end



%% Load data
% Load the data output only for sorted units after currating the data with Phy
params.excludeNoise = true;
params.loadPCs = false;
SpikeStruct = loadKSdir(InputPath, params);
UnitClusters = SpikeStruct.cids;
UnitClustersQ = SpikeStruct.cgs;
Qlabel = {'M','S','U'}; % M: multi-unit, S: single unit, U: Unsorted or Uncertain between noise or unit

% Get the info of that recording
BatID = SpikeStruct.dat_path(1:5);
Date = SpikeStruct.dat_path(7:14);
NChannels = size(SpikeStruct.temps,3);


%% Now calculate quality measures of the clustering
% Load all the data output after currating the data with Phy
params.excludeNoise = false;
params.loadPCs = true;
SpikeStruct = loadKSdir(InputPath, params);
Num_spikes=length(SpikeStruct.ss);

% Loop through time points and clusters and calculate time varying spike sort
% quality measures.
% values for Spike_arrival_times are in us
% Calculate spike arrival time in transceiver time from SpikeStruct, in
% microseconds (Spike_arrival_times)
FileDir = dir(fullfile(Data_folder,'*CSC*.mat'));
Filename=fullfile(FileDir(round(length(FileDir)/2)).folder,FileDir(round(length(FileDir)/2)).name);
% Convert the indices of spike arrival times to real
% time since we can load the info regarding time of file
% onsets, and the sample frequency.
load(Filename, 'Indices_of_first_and_last_samples');

load(Filename, 'Estimated_channelFS_Transceiver');
FS = nanmean(Estimated_channelFS_Transceiver);
load(Filename, 'Timestamps_of_first_samples_usec');
Spike_arrival_times_all=round(get_timestamps_for_Nlg_voltage_samples(SpikeStruct.ss,Indices_of_first_and_last_samples(:,1)',Timestamps_of_first_samples_usec,10^6/FS)); % the time stamps of all the detected spikes, rounded to integer microseconds; note that these are the time stamps of the last channel on this electrode bundle, which differ from the time stamps on the other channels of this electrode bundle by a few sampling periods of the Nlg AD converter

fprintf(1,'*** Calculating dynamic Lratio and Isolation Distance for all units ***\n') 
MinPoint = floor(min(Spike_arrival_times_all)/TimeStep)*TimeStep;
MaxPoint = ceil(max(Spike_arrival_times_all)/TimeStep)*TimeStep;
TimePoints = MinPoint:TimeStep:MaxPoint;
Nwin = length(TimePoints)-1;
TimeLRatio = nan(Nwin, length(UnitClusters));
TimeL = TimeLRatio;
TimeDf = TimeLRatio;
TimeIsolationDistance = TimeLRatio;
for ww=1:Nwin
    fprintf(1,'Time window %d/%d\n',ww,Nwin)
    Spike_local = find((Spike_arrival_times_all>=TimePoints(ww)) .* (Spike_arrival_times_all<TimePoints(ww+1)));
    for SS_i = 1:length(UnitClusters)
        ClusterSpikeID = find(SpikeStruct.clu(Spike_local) == UnitClusters(SS_i));
        Mat_Filename = fullfile(OutputPath,sprintf('%s_%s_TT*_SS*_%d.mat',BatID, Date,UnitClusters(SS_i)));
        TheFile = dir(Mat_Filename);
        load(fullfile(TheFile.folder, TheFile.name), 'ChannelID')
        TetrodeID = nan(length(ChannelID),1);
        for cc=1:length(ChannelID)
            TetrodeID(cc) = find(ChannelID(cc)<=Num_EperBundle:Num_EperBundle:NChannels,1,'first');
        end
        TetrodeID = unique(TetrodeID);
        if length(TetrodeID)==1
            Bundle_channels = (TetrodeID-1)*Num_EperBundle + (1:Num_EperBundle);
            PCAFeatures = reshape(SpikeStruct.pcFeat(Spike_local,:,Bundle_channels), length(Spike_local),size(SpikeStruct.pcFeat,2)*Num_EperBundle);% % from nSpikes x nFeatures x nLocalChannels to nSpikes x nFeatures for all channels
        else
            fprintf(1, 'these data are compilation from spike shapes detected on different tetrodes... Probably crap! but taking all tetrode data for quality assessment\n')
            PCAFeatures = reshape(SpikeStruct.pcFeat(Spike_local,:,:), length(Spike_local),size(SpikeStruct.pcFeat,2)*NChannels);% % from nSpikes x nFeatures x nLocalChannels to nSpikes x nFeatures for all channels
        end
        if length(ClusterSpikeID)<=size(PCAFeatures,2)
            % There is not enough spikes for that time point to
            % calculate the Lratio, we need to have more spikes
            % than the number of features
        else
            [TimeL(ww,SS_i), TimeLRatio(ww,SS_i), TimeDf(ww,SS_i)] = l_ratio(PCAFeatures, ClusterSpikeID);
        end
        [TimeIsolationDistance(ww,SS_i)] = isolation_distance(PCAFeatures, ClusterSpikeID);
    end
end

%% Add something about SNR on spike snippets for each cell

% Overall spike sort quality
fprintf(1,'*** Calculating overall Lratio and Isolation Distance for all units ***\n')
L = nan(1, length(UnitClusters));
LRatio = L;
Df = L;
IsolationDistance = L;
PCAFeatures = reshape(SpikeStruct.pcFeat, Num_spikes,size(SpikeStruct.pcFeat,2)*NChannels);% % from nSpikes x nFeatures x nLocalChannels to nSpikes x nFeatures for all channels
for SS_i = 1:length(UnitClusters)
    fprintf(1,'Unit %d/%d\n', SS_i, length(UnitClusters))
    ClusterSpikeID = find(SpikeStruct.clu == UnitClusters(SS_i));
    if length(ClusterSpikeID)<=8
        % There is not enough spikes for that time point to
        % calculate the Lratio, we need to have more spikes
        % than the number of features
    else
        [L(SS_i), LRatio(SS_i), Df(SS_i)] = l_ratio(PCAFeatures, ClusterSpikeID);
    end
    [IsolationDistance(SS_i)] = isolation_distance(PCAFeatures, ClusterSpikeID);
end
Mat_Filename = fullfile(OutputPath,sprintf('%s_%s_TTAll_SSorted.mat',BatID, Date));
save(Mat_Filename, 'UnitClusters', 'UnitClustersQ', 'TimePoints', 'TimeLRatio', 'TimeL', 'TimeDf','TimeIsolationDistance','LRatio','L','Df','IsolationDistance')
if DebugFig
    figure();
    for SS_i = 1:length(UnitClusters)
        Xtime = (TimePoints(2:end)-TimeStep/2)/(60*10^6);
        Xtime = Xtime-Xtime(1);
        yyaxis left
        if UnitClustersQ(SS_i)==1
            plot(Xtime, TimeLRatio(:,SS_i), 'b--', 'LineWidth',2);
            ylabel('LRatio')
            hold on
            yyaxis right
            plot(Xtime, log10(TimeIsolationDistance(:,SS_i)), 'r--', 'LineWidth',2);
        elseif UnitClustersQ(SS_i) == 2
            plot(Xtime, TimeLRatio(:,SS_i), 'b-', 'LineWidth',2);
            ylabel('LRatio')
            hold on
            yyaxis right
            plot(Xtime, log10(TimeIsolationDistance(:,SS_i)), 'r-', 'LineWidth',2);
        elseif UnitClustersQ(SS_i) ==3
            plot(Xtime, TimeLRatio(:,SS_i), 'b:', 'LineWidth',2);
            ylabel('LRatio')
            hold on
            yyaxis right
            plot(Xtime, log10(TimeIsolationDistance(:,SS_i)), 'r:', 'LineWidth',2);
        else
            error('Impossible to identify cluster quality')
        end
        ylabel('IsolationDistance (log10 scale)')
        xlabel('Time (min)')
        title(sprintf('Spike sorting quality cluster %d Q=%s, LRatio = %.1f, IDist = %.1f', UnitClusters(SS_i), Qlabel{UnitClustersQ(SS_i)}, LRatio(SS_i),IsolationDistance(SS_i)));
        hold off
    end
    figure();
    ColorCode = get(groot,'DefaultAxesColorOrder');
    UUnitClusterQ = unique(UnitClustersQ);
    for qq=1:length(UUnitClusterQ)
        Local = find(UnitClustersQ==UUnitClusterQ(qq));
        scatter(log10(IsolationDistance(Local)),LRatio(Local),[],ColorCode(UUnitClusterQ(qq),:),'filled')
        hold on
    end
    legend('Multi-unit','Single-unit','Unclassified')
    xlabel('IsolationDistance (log10 scale)')
    ylabel('LRatio')
    hold off
end


end
