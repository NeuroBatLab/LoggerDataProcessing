function phy2ssmat(InputPath, OutputPath)
% this function expect that the original CSC files are sitting in
% 'extracted_data' folder at the same level as InputPath

%Hard coded input:
Num_EperBundle = 4; % We work with tetrodes
TimeStep = 20*60*10^6;% Time Step of 30 min for the calculation of the time varying spike sorting quality measures
DebugFig = 1; % Set to 1 to see figures of spike sorting quality.

%% Bandpass parameters for the input raw voltage
BandPassFilter = [600 6000];


% Deal with input variables
if nargin<1
    error('please provide the path to the files containing\nthe snippets and spike arrival time generated by Phy\n');
end

if nargin<2
    OutputPath = InputPath;
    fprintf(1, 'No outputpath indicated, data will be saved under the same folder as they were provided:\n%s\n', OutputPath);
else
    fprintf(1, 'Converted files willbe saved under:\n%s\n', OutputPath);
end

% Get the folder containing the raw data as extracted by extract_logger_data.m
[Root,~]=fileparts(InputPath);
Data_folder = fullfile(Root, 'extracted_data');

% Load the data output after currating the data with Phy
params.excludeNoise = true;
params.loadPCs = true;
SpikeStruct = loadKSdir(ksDir, params);

% Get the info of that recording
BatID = SpikeStruct.dat_path(1:5);
Date = SpikeStruct.dat_path(7:14);
NTemplatePoints = size(SpikeStruct.temps,2);
NChannels = size(SpikeStruct.temps,3);

% BandPass filter for the raw data
[b,a]=butter(6,BandPassFilter/(SpikeStruct.sample_rate/2),'bandpass');

%% Loop through each SU or MU and save data
UnitClusters = SpikeStruct.cids;
Nunits = length(UnitClusters);
Qlabel = {'M','S'}; % M: multi-unit, S: single unit
for uu=1:Nunits
    fprintf(1, 'Processing unit %d/%d\n', uu, Nunits);
    ClustID = UnitClusters(uu);
    ClustQ = Qlabel{SpikeStruct.cgs(uu)};
    SpikeTemplatesID = SpikeStruct.spikeTemplates(SpikeStruct.clu == ClustID);
    SpikePosition_local = SpikeStruct.ss(SpikeStruct.clu == ClustID);
    
    % find on which channel this unit was detected
    Utemplates = unique(SpikeTemplatesID);
    fprintf(1, '%d templates for that unit\n', length(Utemplates));
    ChannelID = nan(length(Utemplates),1);
    Templates = cell(length(Utemplates),1);
    for tt=1:length(Utemplates)
        Templates{tt} = squeeze(SpikeStruct.temps(Utemplates(tt),:,:));
        AmpTemplate = max(Templates{tt}) - min(Templates{tt});
        [~,ChannelID(tt)] = max(AmpTemplate);
        
        FIG = figure();
        subplot(1, length(Utemplates),tt)
        for cc=1:NChannels
            plot(Templates{tt}(:,cc), 'LineWidth',2, 'DisplayName',sprintf('Channel %d',cc))
            hold on
        end
        hold off
        legend('location', 'SouthEast', 'NumColumns',2)
        title(sprintf('Template %d max on Channel %d', tt, ChannelID(tt)));
    end
    
    UChannelID = unique(ChannelID);
    if length(UChannelID)>1
        warning('This unit is formed by spikes that were detected by %d templates belonging to different channels: %d\n Channel %d is taken as a reference for spike arrival times calculations\n', length(Utemplates),UChannelID,UChannelID(1))
        UChannelID = UChannelID(1); % even if the unit is constituted from templates that are max on different channels, only take the first one as a reference
    end
    
    % determine to which tetrode that channel belonged and the associated
    % channels
    TetrodeID = find(UChannelID<Num_EperBundle:Num_EperBundle:NChannels,1,'first');
    Bundle_channels = (TetrodeID-1)*Num_EperBundle + (1:Num_EperBundle);
    
    % Calculate spike arrival time in transceiver time from SpikeStruct, in
    % seconds (Spike_arrival_times)
    FileDir = dir(fullfile(Data_folder,sprintf('*CSC%d.mat', UChannelID-1)));
    Filename=fullfile(FileDir.folder,FileDir.name);
    % Convert the indices of spike arrival times to real
    % time since we can load the info regarding time of file
    % onsets, and the sample frequency.
    load(Filename, 'Indices_of_first_and_last_samples');
    Num_spikes=length(SpikePosition_local);
    load(Filename, 'Estimated_channelFS_Transceiver');
    FS = nanmean(Estimated_channelFS_Transceiver);
    load(Filename, 'Timestamps_of_first_samples_usec');
    Spike_arrival_times=round(get_timestamps_for_Nlg_voltage_samples(SpikePosition_local,Indices_of_first_and_last_samples(:,1)',Timestamps_of_first_samples_usec,10^6/FS)); %#ok<IDISVAR> % the time stamps of all the detected spikes, rounded to integer microseconds; note that these are the time stamps of the last channel on this electrode bundle, which differ from the time stamps on the other channels of this electrode bundle by a few sampling periods of the Nlg AD converter
      
    % For all channels, collect the spike snippets
    Spike_snippets=zeros(NTemplatePoints,Num_EperBundle,Num_spikes);
    FileID = fopen(fullfile(InputPath, SpikeStruct.dat_path));
    for spike_i=1:Num_spikes
        fseek(FileID,(SpikePosition_local(spike_i) - NTemplatePoints)*NChannels*2,-1);
        Data = fread(FileID,[NChannels NTemplatePoints*3], '*uint16','l');
        Voltage_Trace = double(Data(Bundle_channels,:));
        for channel_i=1:length(Bundle_channels)
            Filtered_voltage_trace = filtfilt(b,a,Voltage_Trace(channel_i,:));
            Spike_snippet = Filtered_voltage_trace(NTemplatePoints+(1:NTemplatePoints))';
            Spike_snippets(:,channel_i,spike_i)= Spike_snippet; % save the waveforms of the current spike (units are uV)
        end
    end
    Mat_Filename = fullfile(OutputPath,sprintf('%s_%s_TT%d_SS%s_%d.mat',BatID, Date,TetrodeID,ClustQ,ClustID));
    save(Mat_Filename, 'Spike_arrival_times', 'SpikeTemplatesID', 'Spike_snippets', 'Templates', 'ChannelID','UChannelID')
end

%% Now calculate quality measures of the clustering
% Load the data output after currating the data with Phy
params.excludeNoise = false;
params.loadPCs = true;
SpikeStruct = loadKSdir(ksDir, params);
NoiseClusters = SpikeStruct.cids(SpikeStruct.cgs==0);
SpikePosition_all = SpikeStruct.ss(ismember(SpikeStruct.clu, noiseClusters));% get all detected events
PCAFeatures_noise = SpikeStruct.pcFeat(ismember(SpikeStruct.clu, noiseClusters), :,:);% % nSpikes x nFeatures x nLocalChannels  
        
        % Loop through time points and clusters and calculate time varying spike sort
        % quality measures.
        % values for Spike_arrival_times are in us
        % Calculate spike arrival time in transceiver time from SpikeStruct, in
    % seconds (Spike_arrival_times)
    FileDir = dir(fullfile(Data_folder,'*CSC*.mat'));
    Filename=fullfile(FileDir(round(length(FileDir)/2)).folder,FileDir(round(length(FileDir)/2)).name);
    % Convert the indices of spike arrival times to real
    % time since we can load the info regarding time of file
    % onsets, and the sample frequency.
    load(Filename, 'Indices_of_first_and_last_samples');
    Num_spikes=length(SpikeStruct.ss);
    load(Filename, 'Estimated_channelFS_Transceiver');
    FS = nanmean(Estimated_channelFS_Transceiver);
    load(Filename, 'Timestamps_of_first_samples_usec');
    Spike_arrival_times_all=round(get_timestamps_for_Nlg_voltage_samples(SpikeStruct.ss,Indices_of_first_and_last_samples(:,1)',Timestamps_of_first_samples_usec,10^6/FS)); %#ok<IDISVAR> % the time stamps of all the detected spikes, rounded to integer microseconds; note that these are the time stamps of the last channel on this electrode bundle, which differ from the time stamps on the other channels of this electrode bundle by a few sampling periods of the Nlg AD converter
    
    
        
    
    
    MinPoint = floor(min(Spike_arrival_times)/TimeStep)*TimeStep;
        MaxPoint = ceil(max(Spike_arrival_times)/TimeStep)*TimeStep;
        TimePoints = MinPoint:TimeStep:MaxPoint;
        Nwin = length(TimePoints)-1;
        TimeLRatio = nan(Nwin, length(SS_U_ID));
        TimeL = TimeLRatio;
        TimeDf = TimeLRatio;
        TimeIsolationDistance = TimeLRatio;
        for ww=1:Nwin
            Spike_local = find((Spike_arrival_times>=TimePoints(ww)) .* (Spike_arrival_times<TimePoints(ww+1)));
            for SS_i = 1:length(SS_U_ID)
                ClusterSpikeID = find(Spike_sort_ID(Spike_local) == SS_U_ID(SS_i));
                if length(ClusterSpikeID)<=8
                    % There is not enough spikes for that time point to
                    % calculate the Lratio, we need to have more spikes
                    % than the number of features
                else   
%                     [L(ww,SS_i), LRatio(ww,SS_i), Df(ww,SS_i)] = l_ratio(MaxFeatures(Spike_local,:), ClusterSpikeID);
                      [TimeL(ww,SS_i), TimeLRatio(ww,SS_i), TimeDf(ww,SS_i)] = l_ratio([EFeatures(Spike_local,:) PCAFeatures(Spike_local,:)], ClusterSpikeID);
                end
%                 [IsolationDistance(ww,SS_i)] = isolation_distance(MaxFeatures(Spike_local,:), ClusterSpikeID);
                [TimeIsolationDistance(ww,SS_i)] = isolation_distance([EFeatures(Spike_local,:) PCAFeatures(Spike_local,:)], ClusterSpikeID);
            end
        end
        
        % Overall spike sort quality
        L = nan(1, length(SS_U_ID));
        LRatio = L;
        Df = L;
        IsolationDistance = L;
        for SS_i = 1:length(SS_U_ID)
            ClusterSpikeID = find(Spike_sort_ID == SS_U_ID(SS_i));
            if length(ClusterSpikeID)<=8
                % There is not enough spikes for that time point to
                % calculate the Lratio, we need to have more spikes
                % than the number of features
            else
                %                     [L(ww,SS_i), LRatio(ww,SS_i), Df(ww,SS_i)] = l_ratio(MaxFeatures(Spike_local,:), ClusterSpikeID);
                [L(SS_i), LRatio(SS_i), Df(SS_i)] = l_ratio([EFeatures PCAFeatures], ClusterSpikeID);
            end
            %                 [IsolationDistance(ww,SS_i)] = isolation_distance(MaxFeatures(Spike_local,:), ClusterSpikeID);
            [IsolationDistance(SS_i)] = isolation_distance([EFeatures PCAFeatures], ClusterSpikeID);
        end
        Mat_Filename = fullfile(OutputPath,sprintf('%s_%s_TT%d_SSorted_%d.mat',BatID, Date,TetrodeID,ClustID));
        save(Mat_Filename, 'SS_U_ID', 'TimePoints', 'TimeLRatio', 'TimeL', 'TimeDf','TimeIsolationDistance','LRatio','L','Df','IsolationDistance')
        if DebugFig
            for SS_i = 1:length(SS_U_ID)
                figure()
                Xtime = (TimePoints(2:end)-TimeStep/2)/(60*10^6);
                Xtime = Xtime-Xtime(1);
                yyaxis left
                plot(Xtime, TimeLRatio(:,SS_i), 'b-', 'LineWidth',2);
                ylabel('LRatio')
                hold on
                yyaxis right
                plot(Xtime, log10(TimeIsolationDistance(:,SS_i)), 'r-', 'LineWidth',2);
                ylabel('IsolationDistance (log10 scale)')
                xlabel('Time (min)')
                title(sprintf('Spike sorting quality cluster %d, LRatio = %.1f, IDist = %.1f', SS_U_ID(SS_i), LRatio(SS_i),IsolationDistance(SS_i)));
                hold off
            end
        end 
end
