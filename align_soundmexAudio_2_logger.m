function [Pulse_idx, Pulse_TimeStamp_Transc, File_number, Pulse_samp_audio, Slope_and_intercept,Mean_std_x, Mean_std_Pulse_TimeStamp_Transc,Mean_std_Pulse_samp_audio] = align_soundmexAudio_2_logger(Audio_dir, Loggers_dir, ExpStartTime,varargin)
%%
% Function to correct for clock drift between audio recordings and
% Deuteron logger recordings. This function extract the positions of pulses
% in raw audio recordings and in the time at which these pulses are
% detected by the Deuteron transceiver. A linear fit is run for each audio
% file such that the transceiver time of audio events can be reatrieved
% from the sample indices of these audio events in the continuous raw
% recordings.
%
% INPUT:
% Audio_dir: folder containing the audio recordings
%
% Loggers_dir: dase directory containing loggers data. This script expects
% this directory to contain the sufolders 'loggerx' wher x is the serial
% number of the logger
%
% ExpStartTime: identify the exact session you want to look at by the time
% it started (indicated in the filename
%
% Session_strings: cell of strings used to demarcate start and stop of
% time period to analyze in this script from EVENTLOG file generated by extract_logger_data.
%
% OUTPUT:
% Pulse_idx: common pulse indices identified between soundcard recordings
% and logger recordings.
%
% Pulse_TimeStamp_Transc: times (ms) in transceiver time when TTL pulses arrived on
% the transceiver.
%
% Pulse_samp_audio: sample indices when TTL pulses arrived 
% on the soundcard.
%
% File_number: identity of the audio file to which each pulse belongs
%
% 
%%%
save_options_parameters_CD_figure = 1;
pnames = {'Method', 'Session_strings'};
dflts  = {'risefall',{'record only start' 'record only stop'}};
[Method, Session_strings] = internal.stats.parseArgs(pnames,dflts,varargin{:});


%% Find  the audio files and parameter file for TTL pulses
% Wav_files = dir(fullfile(Audio_dir, sprintf('*%s*mic*.wav', ExpStartTime))); % all microphone recordings .WAV files for the requested experiment/session (soundmexpro format)
TTL_files = dir(fullfile(Audio_dir, sprintf('*%s*ttl*.wav',ExpStartTime)));% all ttl recordings .WAV files for the requested experiment/session (soundmexpro format)
TTL_paramfile = dir(fullfile(Audio_dir,sprintf('*%s*unique_ttl_params.mat',ExpStartTime))); % this is the parameter file generated by generate_zero_playback_file.m (code generating TTL pulse playback sequences)
TTL_param = load(fullfile(TTL_paramfile.folder, TTL_paramfile.name));
AudioEvent_file = dir(fullfile(Audio_dir, sprintf('*%s*events.txt',ExpStartTime)));

%% Extract TTL pulses from the audio recordings
fprintf('Extract TTL pulses index and value from audio recordings\n');
Pulse_idx_audio = cell(length(TTL_files),1); % This cell array withh contain the pulse train index of each TTL pulse identified in the recordings
File_number = cell(length(TTL_files),1); % this cell array will contain the TTL file index number where the corresponding pulses are found
Pulse_samp_audio = cell(length(TTL_files),1); % This cell array will contain the sample index of which each TTL pulse onset in the recordings
Num_Samp_audiofile = nan(length(TTL_files),2); % First column is file ID, second is number of samples

for w = 1:length(TTL_files) % run through all .WAV files and extract audio data and TTL status at each sample
%     if ~strcmp(Wav_files(w).name(end-4), TTL_files(w).name(end-4))
%         error('There is an error in audio files. Each Audio file should have a twin brother TTL file and here:\n%s\n%s\n', Wav_files(w).name, TTL_files(w).name);
%     end
    [Ttl_status, FS] = audioread([Audio_dir filesep TTL_files(w).name]);
    
    Num_Samp_audiofile(w,2)= length(Ttl_status);
    TTLHigh = find(diff(Ttl_status)>0.5)+1; % identify the increases in volatge
    TTLHigh((find(diff(TTLHigh)==1))+1)=[]; % eliminate consecutive points that show a large increase in the TTL pulses, they are just the continuity of a single pulse start (voltage going up)
    TTLLow = find(diff(Ttl_status)<-0.8)+1; % identify the decreases in volatge
    TTLLow((find(diff(TTLLow)==1))+1)=[]; % eliminate consecutive points that show a large decrease in the TTL pulses, they are just the continuity of a single pulse start (voltage going up)
    if length(TTLHigh)~=length(TTLLow)
        error('Error in align_soundmexAudio_2_logger: A ttl pulse was truncated\n');
    end
    
    Pulse_dur_ms = (TTLLow - TTLHigh)/TTL_param.Base_ttl_length; % duration of each pulse in ms
    InterPulse_dur_ms = (TTLHigh(2:end) - TTLLow(1:end-1))/TTL_param.Base_ttl_length; % duration between each pulse in ms (length(InterPulse_dur_ms)=length(Pulse_dur_ms)-1)
    PulseTrainInd = [1; find(round(InterPulse_dur_ms) ~= TTL_param.IPI)+1]; % these are the indices of the elements in Pulse_dur_ms that correspond to the first digit coded by pulse trains
    if unique(round(InterPulse_dur_ms(PulseTrainInd(2:end)-1)/10^3)) ~= TTL_param.IPTI
        fprintf(1, 'Observed inter-train of pulses intervals in seconds:\n')
        unique(round(InterPulse_dur_ms(PulseTrainInd(2:end)-1)/10^3))
        error('trains of pulses are not spaced by the expected InterPulseTrain interval of %d seconds\n', TTL_param.IPTI);
    end
    % Check that PulseTrainInd is what we expect to be
    NPulses = length(PulseTrainInd);
    if any(TTLHigh(PulseTrainInd)' ~= TTLHigh(1) + FS*TTL_param.IPTI*(0:(NPulses-1)))
        error('The TTL pulses are not correctly detected, they are not where we expect them to be!\n')
    end
    
    % Now extract the pulses indices coded in the trains of pulses'
    % durations
    Digits = cell(NPulses,1);
    for pp=1:NPulses
        if pp==NPulses % special case for the last pulse
            Digits{pp} = int2str(round(Pulse_dur_ms(PulseTrainInd(pp) :end)' - TTL_param.Min_ttl_length));
        else
            Digits{pp} = int2str(round(Pulse_dur_ms(PulseTrainInd(pp):PulseTrainInd(pp+1)-1)' - TTL_param.Min_ttl_length));
        end
    end
    Pulse_idx_audio{w} = cell2mat(cellfun(@(X) str2double(regexprep(X, ' ','')), Digits, 'UniformOutput',0));
    % identify the TTL file ID
    Ind_b = strfind(TTL_files(w).name, '_');
    Ind_e = strfind(TTL_files(w).name, '.wav');
    Num_Samp_audiofile(w,1)=str2double(TTL_files(w).name(Ind_b(end)+1 : Ind_e-1));
    File_number{w} = ones(length(Digits),1)*Num_Samp_audiofile(w,1);
    
    % save the 1st sample of each pulse train
    Pulse_samp_audio{w} = TTLHigh(PulseTrainInd);
end
Pulse_idx_audio = cell2mat(Pulse_idx_audio);
Pulse_samp_audio = cell2mat(Pulse_samp_audio);
File_number = cell2mat(File_number);

%% extract TTL status change from the event log generated by Deuteron and extracted by extract_logger_data
% find eventfile from all loggers (TTL pulses are logged in
% transceiver time which is common to all loggers but they don't always log the same pulses)
All_loggers = dir(fullfile(Loggers_dir, 'Logger*'));
NLog = length(All_loggers);
Transceiver_time_drise1 = cell(NLog,1);
Transceiver_time_dfall1 = cell(NLog,1);
fprintf('Extract TTL status changes from ')
for ll=1:NLog
    fprintf('%s ', All_loggers(ll).name);
    Eventfile = dir(fullfile(All_loggers(ll).folder,All_loggers(ll).name, 'extracted_data', '*_EVENTS.mat')); % load file with TTL status info
    load(fullfile(Eventfile.folder, Eventfile.name), 'event_types_and_details', 'event_timestamps_usec');
    B=find(cellfun(@(x) contains(x,Session_strings{1}),event_types_and_details));
    if ~isempty(B) % This is the reference logger, extract the informations about the session
        OnsetTime = 1e-3*event_timestamps_usec(B);
        OffsetTime = 1e-3*event_timestamps_usec(find(cellfun(@(x) contains(x,Session_strings{2}),event_types_and_details)));
    end
        
    Din = find(cellfun(@(x) contains(x,'Digital in'),event_types_and_details));
    Drise1 = find(cellfun(@(x) contains(x,'Digital in rising edge on pin number 1'),event_types_and_details(Din))); % extract which lines in EVENTS correspond to TTL status changes
    Dfall1 = find(cellfun(@(x) contains(x,'Digital in falling edge on pin number 1'),event_types_and_details(Din))); % extract which lines in EVENTS correspond to TTL status changes
%     Ind1=find(diff(Drise1)>2,1,'first');
%     Ind2=find(diff(Drise2)>2,1,'first');
%     Din(Drise1(Ind1))
    Transceiver_time_drise1{ll} = 1e-3*event_timestamps_usec(Din(Drise1)); %#ok<FNDSB> % find times (ms) when TTL status changes to up
    Transceiver_time_dfall1{ll} = 1e-3*event_timestamps_usec(Din(Dfall1)); %#ok<FNDSB> % find times (ms) when TTL status changes to down
end
Transceiver_time_drise1 = unique(cell2mat(Transceiver_time_drise1));
Transceiver_time_dfall1 = unique(cell2mat(Transceiver_time_dfall1));

% restrict the dataset to the time frame we want to look at
if length(OnsetTime)>1 || length(OffsetTime)>1
    error('the recording was re-started')
end    
Transceiver_time_drise1=Transceiver_time_drise1(logical((Transceiver_time_drise1>OnsetTime) .* (Transceiver_time_drise1<OffsetTime)));
Transceiver_time_dfall1=Transceiver_time_dfall1(logical((Transceiver_time_dfall1>OnsetTime) .* (Transceiver_time_dfall1<OffsetTime)));

if strcmp(Method, 'rise')
    % hypothesised indices in Transceiver_time_drise of the onset timestamp of each reported Pulse train
    IndPulse = [1; find((mod(round(diff(Transceiver_time_drise1)/10^3),TTL_param.IPTI)==0).*round(diff(Transceiver_time_drise1)/10^3))+1];
    
    % Identify missing rising edges trains or missing rising edges in pulse trains
    MissingPulsesIdx = find(round(diff(Transceiver_time_drise1(IndPulse)).*10^-3)./TTL_param.IPTI -1); % This is the indices of received rising edge trains after which there are some missing rising edges
    MissingPulsesNum = round(diff(Transceiver_time_drise1(IndPulse)).*10^-3)./TTL_param.IPTI -1; % This is the number of missing rising edge trains
    MissingPulsesNum = MissingPulsesNum(MissingPulsesIdx);
    
    % Initialize vectors
    Pulse_Idx_Transc = cell(length(IndPulse)+sum(MissingPulsesNum),1);
    Pulse_TimeStamp_Transc = nan(length(Pulse_Idx_Transc),1);
    
    % Loop through non-missing pulses and check their value
    Current_pulse = 0;
    for pp=1:length(IndPulse)
        Current_pulse = Current_pulse +1;
        if Current_pulse == 981
            error('buggy pulse')
        end
        if pp==length(IndPulse)
            PulseTrain_Dur = diff(Transceiver_time_drise1(IndPulse(pp):end));
        else
            PulseTrain_Dur = diff(Transceiver_time_drise1(IndPulse(pp):IndPulse(pp+1)));
        end
        if length(PulseTrain_Dur)==1 % One digit pulse either it's an index below 10 or an error
            Pulse_Idx_Transc{Current_pulse} = '0';
            Pulse_TimeStamp_Transc(Current_pulse) = Transceiver_time_drise1(IndPulse(pp));
        else
            Pulse_Idx_Transc{Current_pulse} = [int2str(round(PulseTrain_Dur(1:(end-1))-TTL_param.IPI-TTL_param.Min_ttl_length)') '0'];
            Pulse_TimeStamp_Transc(Current_pulse) = Transceiver_time_drise1(IndPulse(pp));
        end
        % increment the indexing by the number of missing pulses after that
        % one if there are some missing ones
        if any(MissingPulsesIdx == IndPulse(pp))
            Current_pulse = Current_pulse + MissingPulsesNum(MissingPulsesIdx == IndPulse(pp));
        end
    end
    Pulse_Idx_Transc = cell2mat(cellfun(@(X) str2double(regexprep(X, ' ','')), Pulse_Idx_Transc, 'UniformOutput',0));
%     % We might have not catch if some pulse trains were missing right at the begining
%     % Check TTL pulses Idx we're expecting 0 value for the first 9 then 10,
%     % 20...etc
%     TransIndObs = (find(diff(Pulse_Idx_Transc)==10)+1)'; % indices were we reach a new 10
%     TransIndExp = (10:10:(round(length(Pulse_Idx_Transc)/10)*10));
%     if any( TransIndObs - TransIndExp)
%         % some of the consecutive first pulses are missing add some nan or
%         % empty spots according to the number of missing pulse trains
%         NumMissing = 10 - (find(diff(Pulse_Idx_Transc)==10,1,'first')+1);
%         Pulse_Idx_Transc = [nan(NumMissing,1); Pulse_Idx_Transc];
%         Pulse_TimeStamp_Transc = [nan(NumMissing,1); Pulse_TimeStamp_Transc];
%         TransIndObs = (find(diff(Pulse_Idx_Transc)==10)+1)'; % indices were we reach a new 10
%         TransIndExp = (10:10:(round(length(Pulse_Idx_Transc)/10)*10));
%         if any( TransIndObs - TransIndExp) % if this is still not right, error
%             error('In aligh_soundmexAudio_2_logger: Impossible to correct for the missing pulses\n')
%         end
%     end
        
        
    elseif strcmp(Method, 'risefall')
end

%% find common indices
[Pulse_idx, Iaudio, ITransc] = intersect(Pulse_idx_audio, Pulse_Idx_Transc);
Pulse_TimeStamp_Transc = Pulse_TimeStamp_Transc(ITransc);
Pulse_samp_audio = Pulse_samp_audio(Iaudio);
File_number = File_number(Iaudio);

%% Perform a linear fit for each file
Slope_and_intercept = cell(length(TTL_files),1);
Mean_std_x = cell(length(TTL_files),1);
Mean_std_Pulse_TimeStamp_Transc = nan(length(TTL_files),2);
Mean_std_Pulse_samp_audio = nan(length(TTL_files),2);
FileNum_u = unique(File_number);
for ff=1:length(TTL_files)
    Pulse_TimeStamp_Transc_local = Pulse_TimeStamp_Transc(File_number == FileNum_u(ff));
    Pulse_samp_audio_local = Pulse_samp_audio(File_number == FileNum_u(ff));
    Mean_std_Pulse_TimeStamp_Transc(ff,1) = nanmean(Pulse_TimeStamp_Transc_local);
    Mean_std_Pulse_TimeStamp_Transc(ff,2) = nanstd(Pulse_TimeStamp_Transc_local);
    Pulse_TimeStamp_Transc_localzscore = (Pulse_TimeStamp_Transc_local - Mean_std_Pulse_TimeStamp_Transc(ff,1))/Mean_std_Pulse_TimeStamp_Transc(ff,2);
    Mean_std_Pulse_samp_audio(ff,1) = nanmean(Pulse_samp_audio_local);
    Mean_std_Pulse_samp_audio(ff,2) = nanstd(Pulse_samp_audio_local);
    Pulse_samp_audio_localzscore = (Pulse_samp_audio_local - Mean_std_Pulse_samp_audio(ff,1))/Mean_std_Pulse_samp_audio(ff,2);
    [Slope_and_intercept{ff},~,Mean_std_x{ff}]=polyfit(Pulse_samp_audio_localzscore,Pulse_TimeStamp_Transc_localzscore, 1);
    if ff==1
        F=figure();
    else
        clf(F)
        F=figure();
    end
    plot(Pulse_samp_audio_local, Pulse_TimeStamp_Transc_local, 'bo')
    hold on
    xlabel('Audio sample Indices of TTL pulses')
    ylabel('Transceiver time in ms')
    x1 = (min(Pulse_samp_audio_localzscore)-0.5):0.1:(max(Pulse_samp_audio_localzscore)+0.5);
    y1 = polyval(Slope_and_intercept{ff}, x1, [], Mean_std_x{ff});
    x1 = x1 .* Mean_std_Pulse_samp_audio(ff,2) + Mean_std_Pulse_samp_audio(ff,1);
    y1 = y1 .* Mean_std_Pulse_TimeStamp_Transc(ff,2) + Mean_std_Pulse_TimeStamp_Transc(ff,1);
    plot(x1,y1,'r-')
    legend('Observed TTL positions', 'Fit')
    title(sprintf('TTL file %d',FileNum_u(ff)))
    hold off
    pause(1)
    if save_options_parameters_CD_figure
        saveas(F,fullfile(Audio_dir,sprintf('%s_%s_CD_correction_audio_piezo_TTLpositions_file_%d.fig', TTL_paramfile.name(1:6),ExpStartTime,ff)))
    end
end

%% save data to file
save(fullfile(Audio_dir, sprintf('%s_%s_TTLPulseTimes.mat', TTL_paramfile.name(1:6),ExpStartTime)),'Pulse_idx', 'Pulse_TimeStamp_Transc', 'File_number', 'Pulse_samp_audio', 'Slope_and_intercept','Mean_std_x','Mean_std_Pulse_TimeStamp_Transc','Mean_std_Pulse_samp_audio');

%% Plot the drift between clocks
% Get the delay of audio samples due to file changes
FID = fopen(fullfile(AudioEvent_file.folder, AudioEvent_file.name));
Header = textscan(FID, '%s\t%s\t%s\t%s\t%s\t%s\t%s',1);
Data = textscan(FID, '%s\t%f\t%s\t%s\t%f\t%f\t%f');
fclose(FID);
IndFChange = contains(Data{4}(:), 'ChangeFile');
DelayFChange = cumsum(Data{end}(IndFChange));

[~,Isort] = sort(Num_Samp_audiofile(:,1));
CumNum_Samp_audiofile = cumsum(Num_Samp_audiofile(Isort,2));
AudioSamp = Pulse_samp_audio + [zeros(sum(File_number==1),1); CumNum_Samp_audiofile(File_number(File_number>1)-1)];
AudioTime = ((AudioSamp/FS - AudioSamp(1)/FS) + [zeros(sum(File_number==1),1);DelayFChange(File_number(File_number>1)-1)])*10^3;
clock_differences_at_pulses = (Pulse_TimeStamp_Transc - Pulse_TimeStamp_Transc(1)) - AudioTime; % determine difference between transceiver and audio soundcard timestamps when pulses arrived

figure
hold on
plot(AudioTime,clock_differences_at_pulses,'.-');
xlabel('Incoming Audio Pulse Times')
ylabel('Difference between Piezo clock and soundcard clock in ms');
legend('real clock difference');
legend off
MinY = min(clock_differences_at_pulses);
MaxY = max(clock_differences_at_pulses);
for uu=1:length(FileNum_u)
    line([AudioTime(find(File_number == FileNum_u(uu),1,'first')) AudioTime(find(File_number == FileNum_u(uu),1,'first'))], [MinY MaxY])
end
hold off

if save_options_parameters_CD_figure
    saveas(gcf,fullfile(Audio_dir,sprintf('%s_%s_CD_correction_audio_piezo.fig', TTL_paramfile.name(1:6),ExpStartTime)))
end
end