function ntt2mat(InputPath, MatlabImpExpCodePath,OutputPath)
%Hard coded input:
TimeStep = 20*60*10^6;% Time Step of 30 min for the calculation of the time varying spike sorting quality measures
DebugFig = 1; % Set to 1 to see figures of spike sorting quality.
% Deal with input variables
if nargin<1
    error('please provide the path to the files containing\nthe snippets and spike arrival time generated by Neuralynx\n');
end
if nargin<2
    if strcmp('BATMAN-PC', getenv('computername'))
        MatlabImpExpCodePath = 'C:\Users\Batman\Documents\Code\MatlabImportExport_v6.0.0';
    else
        MatlabImpExpCodePath = input('Please indicate the path to your MatlabImportExport_v6.0.0 folder','s');
    end
end
if nargin<3
    OutputPath = InputPath;
    fprintf(1, 'No outputpath indicated, data will be saved under the same folder as they were provided:\n%s\n', OutputPath);
else
    fprintf(1, 'Converted files willbe saved under:\n%s\n', OutputPath);
end

% List the files
Ntt_files = dir(fullfile(InputPath, '*TT*SS*.ntt'));
Num_Ntt = length(Ntt_files);

% Setting parameters for Nlx2MatSpike
 FieldSelectionFlags = [1 0 1 0 1];
%     FieldSelectionFlags= Vector with each item being either a zero (excludes
%                        data) or a one (includes data) that determines which
%                        data will be returned for each record. The order of
%                        the items in the vector correspond to the following:
%                           FieldSelectionFlags(1): Timestamps
%                           FieldSelectionFlags(2): Spike Channel Numbers
%                           FieldSelectionFlags(3): Cell Numbers
%                           FieldSelectionFlags(4): Spike Features
%                           FieldSelectionFlags(5): Samples
HeaderExtractionFlag = 1;
%   HeaderExtractionFlag: Either a zero if you do not want to import the header
%                         or a one if header import is desired
ExtractionMode = 1;
%   ExtractionMode: A number indicating how records will be processed during
%                   import. The numbers and their effect are described below:
%                      1 (Extract All): Extracts data from every record in
%                        the file.

% Save the current path we are in
CurrentPath = pwd;

% Go to the MatlabImportExport folder
eval(sprintf('cd %s',MatlabImpExpCodePath));

% Loop through files, extract data
for Ntt_i=1:Num_Ntt % for each spike sorted unit
    NTT_Filename = fullfile(InputPath, Ntt_files(Ntt_i).name);
    if ~contains(Ntt_files(Ntt_i).name,'Sorted')
        fprintf(1, 'Converting file %d/%d (%s) from ntt to mat\n', Ntt_i, Num_Ntt, NTT_Filename);
        Mat_Filename = fullfile(OutputPath,sprintf('%s.mat', Ntt_files(Ntt_i).name(1:(end-4))));
        [Spike_arrival_times, Spike_sort_ID, Spike_snippets, Header] =...
                     Nlx2MatSpike( NTT_Filename, FieldSelectionFlags,...
                     HeaderExtractionFlag, ExtractionMode,[]);
        save(Mat_Filename, 'Spike_arrival_times', 'Spike_sort_ID', 'Spike_snippets', 'Header')
    else
        fprintf(1, 'Extracting the spike sorting quality from file %d/%d (%s) \n', Ntt_i, Num_Ntt,NTT_Filename);
        Mat_Filename = fullfile(OutputPath,sprintf('%s.mat', Ntt_files(Ntt_i).name(1:(end-4))));
        [Spike_arrival_times, Spike_sort_ID, Spike_snippets] =...
                     Nlx2MatSpike( NTT_Filename, FieldSelectionFlags,...
                     0, ExtractionMode,[]);
        MaxFeatures = squeeze(max(Spike_snippets, [],1))'; % Extracting the peak of each 4Dim spike snippet
        EFeatures = (squeeze(sum(Spike_snippets.^2,1))'.^0.5)./size(Spike_snippets,1);
        PCAFeatures = nan(size(Spike_snippets,3),size(Spike_snippets,2));
        for cc=1:size(Spike_snippets,2)
            [~,Score] = pca(squeeze(Spike_snippets(:,cc,:))'./repmat(EFeatures(:,cc),1,size(Spike_snippets,1)));
            PCAFeatures(:,cc) = Score(:,1);
        end
        clear Spike_snippets
        SS_U_ID = unique(Spike_sort_ID);
        % Loop through time points and clusters and calculate time varying spike sort
        % quality measures.
        % values for Spike_arrival_times are in us
        MinPoint = floor(min(Spike_arrival_times)/TimeStep)*TimeStep;
        MaxPoint = ceil(max(Spike_arrival_times)/TimeStep)*TimeStep;
        TimePoints = MinPoint:TimeStep:MaxPoint;
        Nwin = length(TimePoints)-1;
        TimeLRatio = nan(Nwin, length(SS_U_ID));
        TimeL = TimeLRatio;
        TimeDf = TimeLRatio;
        TimeIsolationDistance = TimeLRatio;
        for ww=1:Nwin
            Spike_local = find((Spike_arrival_times>=TimePoints(ww)) .* (Spike_arrival_times<TimePoints(ww+1)));
            for SS_i = 1:length(SS_U_ID)
                ClusterSpikeID = find(Spike_sort_ID(Spike_local) == SS_U_ID(SS_i));
                if length(ClusterSpikeID)<=8
                    % There is not enough spikes for that time point to
                    % calculate the Lratio, we need to have more spikes
                    % than the number of features
                else   
%                     [L(ww,SS_i), LRatio(ww,SS_i), Df(ww,SS_i)] = l_ratio(MaxFeatures(Spike_local,:), ClusterSpikeID);
                      [TimeL(ww,SS_i), TimeLRatio(ww,SS_i), TimeDf(ww,SS_i)] = l_ratio([EFeatures(Spike_local,:) PCAFeatures(Spike_local,:)], ClusterSpikeID);
                end
%                 [IsolationDistance(ww,SS_i)] = isolation_distance(MaxFeatures(Spike_local,:), ClusterSpikeID);
                [TimeIsolationDistance(ww,SS_i)] = isolation_distance([EFeatures(Spike_local,:) PCAFeatures(Spike_local,:)], ClusterSpikeID);
            end
        end
        
        % Overall spike sort quality
        L = nan(1, length(SS_U_ID));
        LRatio = L;
        Df = L;
        IsolationDistance = L;
        for SS_i = 1:length(SS_U_ID)
            ClusterSpikeID = find(Spike_sort_ID == SS_U_ID(SS_i));
            if length(ClusterSpikeID)<=8
                % There is not enough spikes for that time point to
                % calculate the Lratio, we need to have more spikes
                % than the number of features
            else
                %                     [L(ww,SS_i), LRatio(ww,SS_i), Df(ww,SS_i)] = l_ratio(MaxFeatures(Spike_local,:), ClusterSpikeID);
                [L(SS_i), LRatio(SS_i), Df(SS_i)] = l_ratio([EFeatures PCAFeatures], ClusterSpikeID);
            end
            %                 [IsolationDistance(ww,SS_i)] = isolation_distance(MaxFeatures(Spike_local,:), ClusterSpikeID);
            [IsolationDistance(SS_i)] = isolation_distance([EFeatures PCAFeatures], ClusterSpikeID);
        end
        save(Mat_Filename, 'SS_U_ID', 'TimePoints', 'TimeLRatio', 'TimeL', 'TimeDf','TimeIsolationDistance','LRatio','L','Df','IsolationDistance')
        if DebugFig
            for SS_i = 1:length(SS_U_ID)
                figure()
                Xtime = (TimePoints(2:end)-TimeStep/2)/(60*10^6);
                Xtime = Xtime-Xtime(1);
                yyaxis left
                plot(Xtime, TimeLRatio(:,SS_i), 'b-', 'LineWidth',2);
                ylabel('LRatio')
                hold on
                yyaxis right
                plot(Xtime, log10(TimeIsolationDistance(:,SS_i)), 'r-', 'LineWidth',2);
                ylabel('IsolationDistance (log10 scale)')
                xlabel('Time (min)')
                title(sprintf('Spike sorting quality cluster %d, LRatio = %.1f, IDist = %.1f', SS_U_ID(SS_i), LRatio(SS_i),IsolationDistance(SS_i)));
                hold off
            end
        end 
    end
end
% Go back to the initial folder
eval(sprintf('cd %s',CurrentPath));
end