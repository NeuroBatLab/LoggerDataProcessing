 function extract_logger_data_par(Input_folder,varargin)
%% Given the folder containing logger data from one recording
% session, extract the event, voltage data, spikes arrival times and snippets
% (if neural logger). Spike arrival times are given with the onset of the first .dat
% being the reference (zero time). Events and voltage data are saved as matfiles (MATLAB format).
% Spike arrival times and spike snippets are saved as matfiles, and if
% requested in the NEURALYINX .ntt format. (note: save to .ntt only possible
% under windows).
% -The Neurologger event file contains time stamps from the Neurologger and
% its transceiver, with clock drift between the two -- we correct the clock
% drift so that all time stamps are those of the transceiver clock.
% -Can choose whether or not to save event and voltage data files
% -Before running, need to convert the .NLE event file generated by deuteron to
% csv format using the executable provided by Deuteron:
% Event_File_Reader_v4.7.exe
% NOTE: This code is only compatible with the version of Deuteron 2.73 and
% later.

% Input:    -Input_folder_str: path to the folder containing voltage data files and event file
%               - Output_folder_str: path to the folder where the outputs
%               of the code (voltage and event data in MATLAB or Nlx formats) will be saved.
%  [...] =
%   extract_logger_data(...,'PARAM1',VAL1,'PARAM2',VAL2,...)
%   specifies various parameters of the extraction.
% Valid parameters are the following:
%  Parameter      Value
% 'OutputFolder is the path to the folder where will be saved extracted data.
%                       Default creates a folder in input folder named
%                       extracted_data and saves data there.

% 'BatID'           is the 5 digits chip ID of the subject. Default is
%                       00000. This will be used to indicate the name of
%                       the bat in the filename.

% 'EventFile'       if set to 'none', no event file will be saved;
%                       'one_file' will save all events to a single file;
%                       'many_files' will save all events to one file and
%                       further create one event file for each event type.
%                       Default set to 'one_file'.

% 'Voltage'         Set to True (1) to save voltage data files and spike arrival times and
%                       snippets (default value), False otherwise.

% 'OutSettings'  Set to True (1, defaut value) to save parameters
%                       and figure showing clock difference, False otherwise.

% 'Diary'           Set to True (1, default value) to save all command
%                       window output to a text file, False otherwise.

% 'CD_Estimation'   Method used to estimate unreported clock differences
%                             between the transceiver and the logger.
%                             'fit' is performing a linear fit on all the
%                             reported clock difference between clock
%                             synchronization events to estimate and
%                             correct the clock drift . 'interpolation'
%                             performs a linear interpolation between
%                             consecutive clock difference reports to
%                             estimate the clock drift of events in
%                             between. Default: 'fit'. Linear fit performs
%                             less errors on the estimation of clock drift
%                             than interpolation method (see figure 2).

% 'FileOnsetTime'   Method to estimate the timestamp of the first sample in
%                            each .dat file generated by Deuteron. 'logfile' (default)  extracts
%                            them from the event log. 'cal' calculates them
%                            relative to the time stamp of the first .dat
%                            file in the event log and the number of
%                            samples recorded since then. This last method might
%                            be more accurate, because the event log time stamps are
%                            rounded to integer milliseconds, while the sampling
%                            period is tens of microseconds

%Parameters specific to neural loggers
% 'NlxSave'             Logical. If set to 1, the function save not only
%                           the data (spike times in microseconds and
%                           snippets) in matfile format
%                           (e.g. Tetrode_spikes_time_T1.mat,
%                           Tetrode_spikes_snippets_T1) but also generate 1 .ntt file
%                           per tetrode that can be read by Neuralynx. NOTE
%                           that the function has then to call Mat2NlxSpike
%                           which does not seem to work under mac...
%                           default is 0.
% 'NumElectrodePerBundle'
%                           Number of electrodes per bundle. Default in 4,
%                           set for tetrodes

% 'SpikeCollisionTolerance'
%                           Minimum distance in microseconds between 2
%                           spike events that are detected on all tetrodes
%                           under which these events are considered as
%                           noise. Default = 50 us.

% Code inspired from Wujie Zhang function extract_Nlg_data and Maimon Rose function extract_audio_data. Written by
% Julie Elie
last_code_update='9/09/2018, Julie Elie'; % identifies the version of the code

%% Sorting input arguments
pnames = {'OutputFolder', 'BatID', 'EventFile','Voltage','OutSettings','Diary','CD_Estimation','FileOnsetTime','NlxSave','NumElectrodePerBundle','SpikeCollisionTolerance'};
dflts  = {fullfile(Input_folder, 'extracted_data'), '00000','one_file', 1, 1,1, 'fit', 'logfile',0, 4, 50};
[Output_folder, BatID, EventFile,Save_voltage, Save_param_figure,Diary, CD_Estimation,FileOnsetTime, NlxSave, Num_EperBundle, SpikeCollisionTolerance] = internal.stats.parseArgs(pnames,dflts,varargin{:});

if strcmp(EventFile, 'one_file')
    Save_event_file=1;
elseif strcmp(EventFile, 'many_file')
    Save_event_file=2;
elseif strcmp(EventFile, 'none')
    Save_event_file=0;
else
    Save_event_file = input('WARNING: undefined input for EventFile.\n choose from the following:\n0: no event file saved\n1: save one event file containing all events\n2: save one event file containing all events and one event file for each event type\n');
end

if Save_event_file || Save_voltage || Save_param_figure % if we're saving anything
    if ~exist(Output_folder,'dir') % make the output folder if it doesn't already exist
        mkdir(Output_folder);
    end
end

if Diary
    Now=clock;
    Diary_filename = fullfile(Output_folder, sprintf('%s_Diary_%s_%d%d%d.txt', BatID, date,Now(4),Now(5),round(Now(6)))); %#ok<NASGU>
    diary(Diary_filename)
    diary on
end

disp(['Processing the data in "' Input_folder '"...'])

%% Extract parameters specific to the Logger used from the log file
% Read the event log file.
FID = fopen(fullfile(Input_folder,'EVENTLOG.csv'));
Exp_info = textscan(FID, '%s',3,'Delimiter','\r'); %#ok<NASGU> % The three first lines are old settings of the experiment that are not relevant anymore
Header = textscan(FID, '%s %s %s %s %s %s',1, 'Delimiter', ',');
Data = textscan(FID, '%s %s %f %s %s %s', 'Delimiter', ',');
fclose(FID);

% Collapse details of lines that are continuation of each other
Continued_event_logic = strcmp(Data{:,1}, '-----');
Continued_event_indices = find(Continued_event_logic) ;
for continued_i=1:sum(Continued_event_logic)% for each of the "...Continued" events, add its "Details" to that of the event from which it contnues
    continued_from_i=find(~Continued_event_logic(1:Continued_event_indices(continued_i)),1,'last'); % the last row before the current "...Continued" row that was not -----, ie. the event from which the current "...Continued" row continues
    Data{6}{continued_from_i}=[Data{6}{continued_from_i} Data{6}{Continued_event_indices(continued_i)}];
end
for cc=1:6
    Data{cc}(Continued_event_indices)=[]; % delete all the "...Continued" rows, since their "Details" have already been copied
end

% Identify all columns
if 3 ~= find(strcmp(Header, 'Time (ms from midnight)'))
    error(' The third column does not correspond to the time from midnight\n')
else
    Event_timestamps_usec=Data{3}*1000; % time stamps, converted from ms to us
end
if 4~= find(strcmp(Header, 'Time Source'))
    error(' The fourth column does not correspond to the time source\n')
else
    Event_timestamps_source=Data{4}; % source of time stamps: logger or transceiver
end
if 5~= find(strcmp(Header, 'Event Type'))
    error(' The fifth column does not correspond to the event type\n')
else
    Event_types=Data{5};
end
if 6~= find(strcmp(Header, 'Details'))
    error(' The sixth column does not correspond to the details\n')
else
    Event_types_and_details=strcat(Data{5},{'. '},Data{6}); % event type and details are concatenated together, with a period and space between them, eg. "File started" and "File index: 001" and concatenated into "File started. File index: 001"
end

% get the date of recording
Str = 'Date = ';
IndLT = find(contains(Event_types_and_details,Str));
Date_all = {};
for ii=1:length(IndLT)
    IndLT2 = strfind(Event_types_and_details{IndLT(ii)},Str);
    IndLT3 = strfind(Event_types_and_details{IndLT(ii)},';');
    IndLT3 = IndLT3(find(IndLT3>IndLT2,1));
    Date_temp = Event_types_and_details{IndLT(ii)}((IndLT2+length(Str)): (IndLT3-1));
    Date_all{ii} = [Date_temp(7:end)  Date_temp(4:5) Date_temp(1:2)]; %#ok<AGROW> % reformat the date to yyyymmdd
end
UDate = unique(Date_all);
if length(UDate)>1
    fprintf('Several dates correspond to that recording,\nplease select the correct one by indicating its index\n')
    for ii=size(UDate,1)
        fprintf('%d. %s\n', ii, UDate{ii});
    end
   IndDate = input('Your choice:');
else
    IndDate=1;
end
Date = UDate{IndDate};
% Find the first and last occurence of that date
IndDateStart = find(contains(Date_all, Date),1,'first');
IndDateStop = find(contains(Date_all, Date),1,'last');

% restrict the event data to that particular
% date
CD_ind = find(contains(Event_types_and_details, 'Clocks synchronized')); % Find the synchronization event that just preceded the date line as a starting point
Start = CD_ind(find(CD_ind<IndLT(IndDateStart), 1, 'last'));
if IndDate == length(IndLT) || IndDateStop == length(IndLT)
    Stop = length(Event_timestamps_usec);
else
    Stop = IndLT(IndDateStop+1);
end
Event_timestamps_usec = Event_timestamps_usec(Start:Stop);
Event_timestamps_source = Event_timestamps_source(Start:Stop);
Event_types = Event_types(Start:Stop);
Event_types_and_details = Event_types_and_details(Start:Stop);

% Extract logger parameters
% find the first line in the log that give setting details info
% get the type of logger
Str = 'Logger type=';
IndLT = find(contains(Event_types_and_details,Str),1);
IndLT2 = strfind(Event_types_and_details{IndLT},Str);
LoggerType = Event_types_and_details{IndLT}(IndLT2+length(Str) +(0:3));

% get the serial number of the logger
Str = 'serial number=';
IndLT = find(contains(Event_types_and_details,Str),1);
IndLT2 = strfind(Event_types_and_details{IndLT},Str);
IndLT3 = strfind(Event_types_and_details{IndLT},';');
IndLT3 = IndLT3(find(IndLT3>IndLT2,1));
SerialNumber = Event_types_and_details{IndLT}((IndLT2+length(Str)): (IndLT3-1));
if strcmp(filesep, Input_folder(end))
    [~,F] = fileparts(Input_folder(1:end-1));
else
    [~,F] = fileparts(Input_folder);
end
if ~strcmp(SerialNumber, F((end-length(SerialNumber)+1):end))
    error('The logger Serial Number does not correspond with that of the folder containing it, please fix!\n%s', Input_folder);
end
    
% get the total number of channels, including inactive ones
Str = 'Number of channels=';
IndLT = find(contains(Event_types_and_details,Str),1);
IndLT2 = strfind(Event_types_and_details{IndLT},Str);
IndLT3 = strfind(Event_types_and_details{IndLT},';');
IndLT3 = IndLT3(find(IndLT3>IndLT2,1));
Num_channels = str2double(Event_types_and_details{IndLT}((IndLT2+length(Str)) : (IndLT3-1)));
if strcmp(LoggerType, 'Audi') && (Num_channels~=1)
    error('There is %d channels when we are expecting only one for an audio logger (logger Type = %s)\n', Num_channels, LoggerType)
end

fprintf('\n\n******* Extracting Logger Data **********\nLogger Type: %s\nSerial Number:%s\nNumber of channels:%d\n', LoggerType, SerialNumber, Num_channels);

% Get the reference electrode if there is one
Str = 'Reference Channel = ';
IndLT = find(contains(Event_types_and_details,Str),1);
Ref_channel = [];
if ~isempty(IndLT)
    IndLT2 = strfind(Event_types_and_details{IndLT},Str);
    IndLT3 = strfind(Event_types_and_details{IndLT},';');
    IndLT3 = IndLT3(find(IndLT3>IndLT2,1));
    Str_out = Event_types_and_details{IndLT}((IndLT2+length(Str)) : (IndLT3-1));
    if ~strcmp(Str_out, 'GND')
        Ref_channel = str2double(Str_out);
    end
else
    fprintf('There is no reference channel.\n');
end

% Get the active channel list if more than one channel
if Num_channels>1
    Str = 'Channel Map = ';
    IndLT = find(contains(Event_types_and_details,Str),1);
    IndLT2 = strfind(Event_types_and_details{IndLT},Str);
    IndLT3 = strfind(Event_types_and_details{IndLT},';');
    IndLT3 = IndLT3(find(IndLT3>IndLT2,1));
    Active_channels = sort(str2num(Event_types_and_details{IndLT}((IndLT2+length(Str)) : (IndLT3-1)))); %#ok<ST2NM>
else
    Active_channels = 0;
end

% get the data format
Str = 'ADC data format=';
IndLT = find(contains(Event_types_and_details,Str),1);
IndLT2 = strfind(Event_types_and_details{IndLT},Str);
IndLT3 = strfind(Event_types_and_details{IndLT},';');
IndLT3 = IndLT3(find(IndLT3>IndLT2,1));
Str_out = Event_types_and_details{IndLT}((IndLT2+length(Str)) : (IndLT3-1));
if strcmp(Str_out, '16-bit signed')
    ADC_data_format = 'int16';
elseif strcmp(Str_out, '16-bit unsigned')
    ADC_data_format = 'uint16';
else
    error('unable to parse data format: %s\n',Str_out);
end

% get the sampling frequency of the logger
Str = 'sampling frequency=';
IndLT = find(contains(Event_types_and_details,Str),1);
IndLT2 = strfind(Event_types_and_details{IndLT},Str);
IndLT3 = strfind(Event_types_and_details{IndLT},'Hz');
IndLT3 = IndLT3(find(IndLT3>IndLT2,1));
FS = str2double(Event_types_and_details{IndLT}((IndLT2+length(Str)) : (IndLT3-1)));

% get the coversion from bits to uV
% voltage in microvolt = (raw AD count - AD_count_for_zero_voltage) * AD_count_to_uV_factor
% this code does not convert the AD counts to voltages--this conversion factor is saved along with the AD counts
% in the same .mat files, to be used by detect_spikes_from_raw_voltage_trace.m
Str = 'resolution=';
IndLT = find(contains(Event_types_and_details,Str),1);
IndLT2 = strfind(Event_types_and_details{IndLT},Str);
IndLT3 = strfind(Event_types_and_details{IndLT},'V/bit');
IndLT3 = IndLT3(find(IndLT3>IndLT2,1));
ADC2uV_resolution = str2double(Event_types_and_details{IndLT}((IndLT2+length(Str)) : (IndLT3-1)))*1e6;

% get the AD count that represents zero volt
% This value will be subtracted from the recorded AD counts.
Str = 'ADC nominal offset=';
IndLT = find(contains(Event_types_and_details,Str),1);
IndLT2 = strfind(Event_types_and_details{IndLT},Str);
IndLT3 = strfind(Event_types_and_details{IndLT},' bits');
IndLT3 = IndLT3(find(IndLT3>IndLT2,1));
ADC_zero_voltage = str2double(Event_types_and_details{IndLT}((IndLT2+length(Str)) : (IndLT3-1)));

% get the AD count for unwritten data.
% When recording is stopped (at the end of a recording session or in the
% middle), the latest recorded data are written to the latest .DAT file,
% which partially fills it and leaves all samples in the unfilled portion
% of the file at their default value, which is for instance 65535 (the 16-bit unsigned
% integer with all bits being ones) in the version of Neurolog-16.
Str = 'Erased data in hex=';
IndLT = find(contains(Event_types_and_details,Str),1);
IndLT2 = strfind(Event_types_and_details{IndLT},Str);
IndLT3 = strfind(Event_types_and_details{IndLT},';');
IndLT3 = IndLT3(find(IndLT3>IndLT2,1));
ADC_unwritten_data = str2double(Event_types_and_details{IndLT}((IndLT2+length(Str)) : (IndLT3-1)));

% get the root name for .dat files; eg. 'NEUR' for neurologger file names like "NEUR_003.DAT"
Str = 'Flash File Root Name = "';
IndLT = find(contains(Event_types_and_details,Str),1);
IndLT2 = strfind(Event_types_and_details{IndLT},Str);
IndLT3 = strfind(Event_types_and_details{IndLT},'";');
IndLT3 = IndLT3(find(IndLT3>IndLT2,1));
Dat_rootname = Event_types_and_details{IndLT}((IndLT2+length(Str)) : (IndLT3-1));
AllDatFiles = dir(fullfile(Input_folder, '*.dat'));
if ~strcmp(Dat_rootname, AllDatFiles(1).name(1:4))
    error('the root name for data files indicated in the log does not correspond to those in the folder:%s\n', Dat_rootname);
end


%% Get a reference for the time
LoggerTime_ref = Event_timestamps_usec(find(contains(Event_types_and_details,'Started recording'),1));
% Event_timestamps_usec = Event_timestamps_usec - LoggerTime_ref;

%% Synchronize logger to transceiver
% Change all logger time stamps to the corresponding times of the
% transceiver clock (the transceiver clock and logger clock run at different
% speeds); the clock difference (CD) is defined as logger time minus transceiver
% time

% First find all the reports of clock differences and the corresponding time stamps
% of the logger
disp('->Retrieving time stamps of clock drift reports')
Str = 'CD=';
Ind_CD = find(contains(Event_types_and_details,Str));
CD_sec=nan(length(Ind_CD),1);
CD_logger_stamps=nan(length(Ind_CD),1);
for CD_i=1:length(Ind_CD)
    IndLT2 = strfind(Event_types_and_details{Ind_CD(CD_i)},Str);
    IndLT3 = strfind(Event_types_and_details{Ind_CD(CD_i)},' ');% find the empty space after the clock difference value from eg. "...CD=-0.001000 RR=0..."
    IndLT3 = IndLT3(find(IndLT3>IndLT2,1));
    CD_sec(CD_i)=str2double(Event_types_and_details{Ind_CD(CD_i)}((IndLT2+length(Str)) : (IndLT3-1))); % clock differences are in s
    CD_logger_stamps(CD_i)=Event_timestamps_usec(Ind_CD(CD_i)); % the time of the logger clock when the clock difference was reported
end

% Work between 2 clock synchronization events. It is assumed that the drift
% is mostly linear between these synchronization events.
Ind_Start = find(contains(Event_types_and_details,'Started recording'),1);
Ind_Sync = sort([Ind_Start; find(contains(Event_types_and_details,'Clocks synchronized')); length(Event_types_and_details)]); % synchronization evenst, and the first and last event
Ind_Sync = Ind_Sync(Ind_Sync>= Ind_Start); 
Ind_Logger_times=find(contains(Event_timestamps_source,'Logger')); % events originally logged with logger time stamps
Estimated_CD=nan(length(Ind_Logger_times),1); % estimated clock difference for the logger time stamps identified by Ind_Logger_times
CD_sec_Outsider = []; % value of clock drift reports that are discarded
Outsider = []; % Indices of clock drift reports that are discarted

for unsync_i=1:length(Ind_Sync)-1 % for each of the intervals between consecutive "Clocks synchronized" events after we started recording
    % Identify the events that were logged in logger time for that data
    % section
    Ind_Logger_times_local=find(Ind_Logger_times>=Ind_Sync(unsync_i) & Ind_Logger_times<Ind_Sync(unsync_i+1)); % all the events that were originally logged with transceiver time stamps in the current interval
    if isempty(Ind_Logger_times_local) % if there is no events in the current interval whose clock difference need to be estimated
        continue
    end
    % Identify the indices of the clock reports for that section of data
    if contains(Event_types_and_details(Ind_Sync(unsync_i)),'Clocks synchronized')
        Ind_CD_local=find(Ind_CD>Ind_Sync(unsync_i) & Ind_CD<Ind_Sync(unsync_i+1) & ~isnan(CD_sec)); % all the events in the current interval when clock difference was reported and not NaN (ignore when Deuteron software gives weird blank output (e.g. CD=--))
    elseif contains(Event_types_and_details(Ind_Sync(unsync_i)),'Started recording')
        Ind_CD_local=find(Ind_CD>Ind_Start & Ind_CD<Ind_Sync(unsync_i+1) & ~isnan(CD_sec));
        Ind_CD_local = [find(Ind_CD<Ind_Start & Ind_CD>1,1,'last'); Ind_CD_local]; %#ok<AGROW> % add just the previous clock drift measurement before the start of the recording
    end
    CD_sec_local = CD_sec(Ind_CD_local);
 
    % Get rid of outsider: obvious error of Deuteron in the Clock drift report
    Outsider_diff = find(abs(diff(CD_sec_local))> (nanmean(abs(diff(CD_sec_local))) + 4*nanstd(abs(diff(CD_sec_local))))); % identify indices of the derivative of CD_sec that are 4 standard deviation away from the mean
    Outsider_local = Outsider_diff(find(diff(Outsider_diff)==1)+1); % identify consecutive indices of the derivative that are 4 standard deviation away from the mean derivative and deduct the indices of the actual outsider points in CD_sec
    CD_sec_Outsider = [CD_sec_Outsider; CD_sec_local(Outsider_local)]; %#ok<AGROW>
    CD_sec_local(Outsider_local) = []; % erase that clock drift report from the local section of data
    CD_sec(Ind_CD_local(Outsider_local))= NaN; % replace that clock drift report by NaN in the whole data section
    Outsider = [Outsider; Ind_CD_local(Outsider_local)]; %#ok<AGROW> Keep track of the index ofthe removed clock drift report
    Ind_CD_local(Outsider_local) = []; %remove that indices of clock drift report from the set of usable ones
    
    % Convert the events that were logged in logger time
    % to transceiver time for each chunck of data
    if length(Ind_CD_local)==1 % if there is only one reported clock difference in the current interval, then use that for all unreported clock differences
        Estimated_CD(Ind_Logger_times_local)=CD_sec_local*1e6;
    else
        % Estimate the clock differences in microseconds at all the time points in the
        % current interval that were originally logged with the
        % logger clock
        if strcmp(CD_Estimation, 'fit')
            % centering and scaling data before doing the fit
            CD_logger_stamps_localmean = nanmean(CD_logger_stamps(Ind_CD_local));
            CD_logger_stamps_localstd = nanstd(CD_logger_stamps(Ind_CD_local));
            CD_logger_stamps_zscore = (CD_logger_stamps(Ind_CD_local) - CD_logger_stamps_localmean)/CD_logger_stamps_localstd;
            CD_sec_local_mean = nanmean(CD_sec_local);
            CD_sec_local_std = nanstd(CD_sec_local);
            CD_sec_local_zscore = (CD_sec_local - CD_sec_local_mean)/CD_sec_local_std;
            [slope_and_intercept,~,mean_std_x]=polyfit(CD_logger_stamps_zscore, CD_sec_local_zscore, 1);
            Event_timestamps_usec_local_zscore = (Event_timestamps_usec(Ind_Logger_times(Ind_Logger_times_local)) - CD_logger_stamps_localmean)/CD_logger_stamps_localstd;
            Estimated_CD(Ind_Logger_times_local)=1e6 * (CD_sec_local_std * polyval(slope_and_intercept,Event_timestamps_usec_local_zscore,[],mean_std_x) + CD_sec_local_mean);
            % Estimate by fitting a line over the clock differences of
            % all the PC-generated comments in the current interval
        elseif strcmp(CD_Estimation, 'interpolation')
            Estimated_CD(Ind_Logger_times_local)=interp1(CD_logger_stamps(Ind_CD_local), CD_sec_local*1e6, Event_timestamps_usec(Ind_Logger_times(Ind_Logger_times_local)),'linear','extrap');
            % Estimate by linearly interpolating between the clock
            % differences of each pair of consecutive PC-generated
            % comments; also extrapolates for time points before the
            % first PC-generated comment or after the last          
        end
    end
    if any(isnan(Estimated_CD(Ind_Logger_times_local)))
        disp('Unable to estimate clock differences at the following events...')
        Event_types_and_details(Ind_Logger_times_local)
    end
end

if length(Ind_Sync)==2
    disp('There was no clock synchronization event during the experiment')
end

Event_timestamps_usec(Ind_Logger_times)=Event_timestamps_usec(Ind_Logger_times) - Estimated_CD; % convert the time stamps that were originally logger times to transceiver times
%Event_timestamps_usec=round(Event_timestamps_usec); % round all time stamps to integer microseconds

% Convert time logger stamps of clock difference reports to transceiver time stamps
CD_transceiver_stamps=CD_logger_stamps-CD_sec*1e6;

% plot the result of clock difference correction to check for mistakes
Figure1 = figure();
hold on
legend('Location','best', 'AutoUpdate', 'on')
plot((CD_transceiver_stamps-LoggerTime_ref)/(1e6*60), CD_sec*1e3,'r+', 'DisplayName','Recorded clock differences') % transceiver stamps in min at clock difference reports vs. the reported clock differences that were used for estimation
plot((Event_timestamps_usec(Ind_Logger_times)-LoggerTime_ref)/(1e6*60),Estimated_CD/1e3,'b.', 'DisplayName','Estimated clock differences') % transceiver times in minutes vs. the estimated clock differences for all the time stamps that were originally logger times
if length(Outsider)>=1
    plot((CD_logger_stamps(Outsider)-CD_sec_Outsider-LoggerTime_ref)/(1e6*60), CD_sec_Outsider*1e3,'ro', 'DisplayName','Clock drift report excluded') % Clock drift report excluded from the fit
end
if length(Ind_Sync)>2
    plot((Event_timestamps_usec(Ind_Sync(2:end-1))-LoggerTime_ref)/(1e6*60),zeros(length(Ind_Sync(2:end-1)),1),'k*','DisplayName', 'Clock synchronization events') % the events when the two clocks are synchronized in minutes
end
    legend('Location','best', 'AutoUpdate', 'off')
title(sprintf('%s %s #Abherent Clock drift report: %d', LoggerType, SerialNumber, length(Outsider)));
% Even right after clock synchronization, the reported clock difference
% may not be zero, because there is a finite uncertainty in the
% reported clock difference
ylabel('Logger time - transceiver time (ms)')
xlabel('Transceiver time (minutes) from recording start')


%% save event files in MATLAB format
if Save_event_file
    disp('->Saving event file')
    Filename=fullfile(Output_folder, sprintf('%s_%s_EVENTS.mat', BatID,Date));
    clear OUT
    OUT.event_timestamps_usec=Event_timestamps_usec;
    OUT.event_types_and_details=Event_types_and_details;
    OUT.logger_serial_number = SerialNumber;
    OUT.logger_type = LoggerType;
    OUT.Bat_id = BatID;
    OUT.Date = Date;
    save(Filename,'-struct','OUT')
    disp(['Event data saved to: ' Filename])
    
    if Save_event_file==2 % if also saving separate event files for each event type
        Uevent_type=unique(Event_types); % all the event types
        clear variables_to_save
        for event_type_i=1:length(Uevent_type)
            Event_local=Uevent_type{event_type_i};
            Ind_Event=ismember(Event_types,Event_local); % find all the events of this type
            Filename=fullfile(Output_folder_str,sprintf('%s_%s_EVENTS_%s.mat', BatID, Date, Event_local));
            OUT.event_timestamps_usec=Event_timestamps_usec(Ind_Event);
            OUT.event_types_and_details=Event_types_and_details(Ind_Event);
            OUT.logger_serial_number = SerialNumber;
            OUT.logger_type = LoggerType;
            OUT.Bat_id = BatID;
            OUT.Date = Date;
            save(Filename,'-struct','OUT')
            disp(['Event data saved to: ' Filename])
        end
    end
end

%% Save the AD counts (in bits) encoding the raw voltage traces
if Save_voltage
    disp('->Extracting voltage traces')
    ADC_sampling_period_usec_Logger=1e6/(FS*Num_channels); % the logger AD converter samples each channel sequentially, so its sampling period is the sampling period of a single channel divided by the number of channels
    Nactive_channels=length(Active_channels);
    
    % Find the time stamps identifying start of a new data file
    Ind_file_start=find(ismember(Event_types,'File started')); % find the 'File started' events
    File_start_timestamps=Event_timestamps_usec(Ind_file_start);
    File_start_timestamps_LogRef = (Data{3}(Ind_file_start))*1000; % Time in microseconds
    File_start_details=Event_types_and_details(Ind_file_start); % these are eg. "File started. File index: 000"
    Nfiles=length(File_start_timestamps);
    if length(AllDatFiles) ~=Nfiles
        fprintf('WARNING: discrepancy between the number of expected files according to the log (%d) and the number of actual .dat files in folder (%d)\n', Nfiles, length(AllDatFiles));
    end
    
    % Find the indices among these data files of those that where stopped before the
    % end of the file
    Ind_stop_recording=find(ismember(Event_types_and_details,'Mode change. Stopped recording'));
    Ind_partial_files=nan(length(Ind_stop_recording),1);
    for stop_i=1:length(Ind_stop_recording) % for each of the "Stopped recording" events
        Ind_partial_files(stop_i) = find((Ind_file_start<Ind_stop_recording(stop_i)),1, 'last'); % the last "File started" event before the "Stopped recording" event
    end
    Ind_partial_files=unique([Ind_partial_files; length(Ind_file_start)]); % add in the last .DAT file, in case the battery runs out or the logger is turned off before the "stop recording" button is pressed, this last file is not followed by a "Stopped recording" event
    
    % Initialize some check variables
    FirstNan = nan(Nactive_channels,1);
    Samples_per_channel_per_file = nan(Nactive_channels,1);
    
    % Loop through channels then through files and extract data
    parfor active_channel_i=1:Nactive_channels
        % Loop through dat files and extract data
        Missing_files = nan(Nfiles,1); % this logical vector keeps track of missing files
        Ind_first_file=1; % as the code processes each .DAT file in sequence, this variable will be updated to reflect the index of the first file during the current period of continuous recording (eg. if recording was stopped and restarted during one experimental session, this would be the first file after recording was restarted)
        File_timestamp_discrepancies_ms=nan(Nfiles,1); % for each .DAT file, the file start time stamp read from the event log minus that calculated by number of samples from recording start
        Ind_firstNlast_samples = nan(Nfiles,2);% for a given channel, the indices of the first and last samples of every .DAT file, counting from the beginning of the recording; this is the same for all recording channels
        Estimated_channelFS_Transceiver = nan(Nfiles-1,1); % The sample frequency in transceiver time can only be estimated up to the one but the last file
        Estimated_channelFS_Logger = nan(Nfiles-1,1); % The sample frequency in logger time can only be estimated up to the one but the last file
        Estimated_channelT_Transceiver = nan(Nfiles-1,1); % The sample frequency in transceiver time can only be estimated up to the one but the last file
        Estimated_channelT_Logger = nan(Nfiles-1,1); % The sample frequency in logger time can only be estimated up to the one but the last file
    
        for File_i=1:Nfiles % for each .DAT file
            % open the data file
            Str = 'index: ';
            IndLT2 = strfind(File_start_details{File_i},Str); %#ok<PFBNS>
            File_num_ID=File_start_details{File_i}((IndLT2+length(Str)): end); % eg. find "003" from "File started. File index: 003"
            if length(File_num_ID)<4
                File_num_ID = sprintf('%d%s',zeros(4-length(File_num_ID),1),File_num_ID);
            end
            fprintf('Channel %d/%d Reading file %d/%d: %s...\n',active_channel_i,Nactive_channels,File_i,Nfiles,File_num_ID);
            File_name=[Dat_rootname File_num_ID '.DAT']; % eg. "NEUR_003.DAT"
            if ~exist(fullfile(Input_folder,File_name),'file')
                Missing_files(File_i)=1;
                disp(['Cannot open ' File_name '; continuing to next file...']);
                if File_i==1
                    Ind_firstNlast_samples(File_i,1) = 1;
                else
                    Ind_firstNlast_samples(File_i,1) = Ind_firstNlast_samples(File_i-1,2)+1;
                    Ind_firstNlast_samples(File_i,2) = Ind_firstNlast_samples(File_i,1) + length(File_data)/Num_channels - 1;
                    AD_count_channeli_all_files(Ind_firstNlast_samples(File_i,1):Ind_firstNlast_samples(File_i,2))=zeros(1,diff(Ind_firstNlast_samples(File_i,:))+1); % There is no data points for this chunck
                end
                continue
            else
                Missing_files(File_i)=0;
            end
            File_id=fopen(fullfile(Input_folder,File_name)); % open the .DAT file for binary read access by MATLAB
            File_data=fread(File_id,ADC_data_format); % import the AD count data as a single column vector with the class indicated by the logger
            fclose(File_id); % close the .DAT file
            
            % Initialize output vectors for the channel
            if find(~Missing_files(~isnan(Missing_files)),1, 'first') == File_i %  True for the first .DAT file loaded
                Samples_per_channel_per_file(active_channel_i)=length(File_data)/Num_channels;
                AD_count_channeli_all_files=nan(1,Samples_per_channel_per_file(active_channel_i)*Nfiles); % the variable where all voltage data will be saved for that channel
                Timestamps_first_samples_usec=nan(1,Nfiles); % the time stamps of the first sample of each file for that channel
                % These are the only time stamps that will be saved if saving in
                % the .mat format, because (1) these are the only time stamps the
                % actual logs, (2) the time stamps of all samples can be
                % calculated from these, and (3) this saves storage space. If we do
                % want to save a time stamp for every sample, we should initialize
                % here a "uint16" zeros vector the same size as
                % "AD_count_all_channels_all_files_int16" above. The time stamps
                % are microseconds from midnight, there are 8.64e10 microseconds in
                % a day, so the unsigned 16-bit integer format is sufficient to
                % store the time stamps, and saves storage and memory compared to
                % other formats.
                
                % Check the start and stop indices of previous files that
                % were not loaded and filled them in.
                if File_i~=1
                    IndMissFiles = sort(find(Missing_files(1:File_i)), 'descend');
                    for ii=1:length(IndMissFiles)
                        mm = IndMissFiles(ii);
                        Ind_firstNlast_samples(mm,2) = Ind_firstNlast_samples(mm,1) + length(File_data)/Num_channels - 1;
                        AD_count_channeli_all_files(Ind_firstNlast_samples(mm,1):Ind_firstNlast_samples(mm,2))=zeros(1,diff(Ind_firstNlast_samples(mm,:))+1); % There is no data points for this chunck
                    end
                end
                
            end
            
            % Identify the first and last sample (if this is a partially
            % written file take that into account)
            if File_i==1
                Ind_firstNlast_samples(File_i,1) = 1;
            else
                Ind_firstNlast_samples(File_i,1) = Ind_firstNlast_samples(File_i-1,2)+1;
            end
            Last_recorded_sample=find(diff(File_data),1,'last'); % the unwritten samples at the end of the file should all have differences between consecutive samples equal to 0, so the index of the last nonzero difference is the index of the last recorded sample
            if any(File_i==Ind_partial_files) % if the current .DAT file is partially filled unwritten samples are expected
                if any(File_data(Last_recorded_sample+1:end)~=ADC_unwritten_data)
                    warning('Error finding the unwritten samples in File %s: the last consecutive data samples with same value (%d) does not equal the default value (%d).\n', File_num_ID, File_data(Last_recorded_sample+1), ADC_unwritten_data);
                end
                if mod(Last_recorded_sample,Num_channels)~=0 % checks for any remainder from the division of the index of the last recorded sample by the number of channels
                    disp(['Logger did not finish recording from all channels in the last AD conversion period before stopping recording during File ' File_num_ID '; data from the unfinished AD conversion period discarded.'])
                    Ind_firstNlast_samples(File_i,2)=Ind_firstNlast_samples(File_i,1) + floor(Last_recorded_sample/Num_channels);
                else
                    Ind_firstNlast_samples(File_i,2)=Ind_firstNlast_samples(File_i,1) + Last_recorded_sample/Num_channels;
                end
            else
                if Last_recorded_sample ~= (length(File_data)-1)
                    if any(File_data(Last_recorded_sample+1:end)==ADC_unwritten_data)
                        fprintf('Unexpectedly for a non-interrupted file, some consecutive data samples show the same value %d equal to the value of unwritten samples %d\n', File_data(Last_recorded_sample+1),ADC_unwritten_data);
                    else
                        fprintf('Unexpectedly for a non-interrupted file, some consecutive data samples show the same value %d but they are different from the  value of unwritten samples %d\n', File_data(Last_recorded_sample+1), ADC_unwritten_data);
                    end
                end
                Ind_firstNlast_samples(File_i,2) = Ind_firstNlast_samples(File_i,1) + length(File_data)/Num_channels - 1;
                if length(File_data)/Num_channels~=Samples_per_channel_per_file(active_channel_i)
                    fprintf('Data vector is unexpectedly shorter: %d instead of %d samples\n', length(File_data)/Num_channels, Samples_per_channel_per_file(active_channel_i));
                end
            end
            
             % Extract voltage data for active channels
            AD_count_data=reshape(File_data,Num_channels,[]); % reshape the data: each row is the data for a channel
            if any(Ref_channel) % if a channel will be used as reference
                AD_count_data=AD_count_data(Active_channels(active_channel_i)+1,:)-AD_count_data(Active_channels==Ref_channel,:); %#ok<PFBNS> % subtract the AD counts (equivalently, voltages) of the reference channel from those of all other channels
            else
                AD_count_data=AD_count_data(Active_channels(active_channel_i)+1,:); % take only this active channel, note that Active_channels are the ID of channels on the logger from 0 to Num_channels-1
            end
            AD_count_data=AD_count_data-ADC_zero_voltage; % subtract the AD count that represents 0 voltage
            AD_count_data=-AD_count_data; % the voltage trace is inverted so that spikes start with an increase in voltage followed by a decrease
            
            % Estimate the sample frequency and period from both the
            % transceiver and the logger according to timestamp of file
            % onsets
            if File_i<Nfiles && ~any(File_i==Ind_partial_files)
                Estimated_channelFS_Transceiver(File_i) = length(AD_count_data)/(File_start_timestamps(File_i+1) - File_start_timestamps(File_i))*10^6; %#ok<PFBNS> % Estimated sample frequency of the channel for that file in Hz in transceiver time
                Estimated_channelFS_Logger(File_i) = length(AD_count_data)/(File_start_timestamps_LogRef(File_i+1) - File_start_timestamps_LogRef(File_i))*10^6; %#ok<PFBNS> % Estimated sample frequency of the channel for that file in Hz in transceiver time
                Estimated_channelT_Transceiver(File_i) = (File_start_timestamps(File_i+1) - File_start_timestamps(File_i))/length(AD_count_data); % Estimated sampling period of the channel for that file in microseconds in transceiver time
                Estimated_channelT_Logger(File_i) = (File_start_timestamps_LogRef(File_i+1) - File_start_timestamps_LogRef(File_i))/length(AD_count_data); % Estimated sampling period of the channel for that file in microseconds in transceiver time
            end
            
            % Extract the time stamps of the first sample for each channel
            if File_i>1
                Total_Nb_Samples = Ind_firstNlast_samples((File_i-1),2)-Ind_firstNlast_samples(Ind_first_file,1)+1;
            else
                Total_Nb_Samples = 0;
            end
            if File_i<Nfiles && ~any(File_i==Ind_partial_files)
                FS_local_Trans = Estimated_channelFS_Transceiver(File_i);
                FS_local_Log = Estimated_channelFS_Logger(File_i);
            else
                FS_local_Trans = Estimated_channelFS_Transceiver(File_i-1);
                FS_local_Log = Estimated_channelFS_Logger(File_i-1);
            end
            File_timestamps_usec_from_sampling_period=File_start_timestamps(Ind_first_file) + Total_Nb_Samples*1e6/FS_local_Trans; % time stamp of the first sample of the current .DAT file = the number of samples since recording start * sampling period of the transceiver at that time point
            File_timestamps_usec_from_sampling_period_LogRef=File_start_timestamps_LogRef(Ind_first_file) + Total_Nb_Samples*1e6/FS_local_Log; % time stamp of the first sample of the current .DAT file = the number of samples since recording start * sampling period of the logger
            
            File_timestamp_discrepancies_ms(File_i)=File_start_timestamps(File_i)/1000-File_timestamps_usec_from_sampling_period/1000; % difference between the event log time stamp and the time stamp calculated by counting samples, after roundig both to integer ms
            File_timestamp_discrepancies_LogRef=File_start_timestamps_LogRef(File_i)/1000-File_timestamps_usec_from_sampling_period_LogRef/1000; % difference between the event log time stamp and the time stamp calculated by counting samples, after roundig both to integer ms
            
            Figure1; %#ok<VUNUS>
            Ii_local = find(Ind_Logger_times == Ind_file_start(File_i)); %#ok<PFBNS>
            hold on
            if File_i==Nfiles
                legend('AutoUpdate','on')
            end
            plot((File_start_timestamps(File_i)-LoggerTime_ref )/(1e6*60),Estimated_CD(Ii_local)/1e3,'g.', 'DisplayName', 'File onset log') %#ok<PFBNS> % transceiver times vs. the estimated clock differences for all the time stamps that were originally logger times
            plot((File_timestamps_usec_from_sampling_period-LoggerTime_ref )/(1e6*60),Estimated_CD(Ii_local)/1e3,'c.', 'DisplayName', 'File onset estimated') % transceiver times vs. the estimated clock differences for all the time stamps that were originally logger times
            if File_i==Nfiles
                hold off
            end
            
            
            if File_timestamp_discrepancies_ms(File_i)~=File_timestamp_discrepancies_LogRef && abs(File_timestamp_discrepancies_ms(File_i))>0.5
                fprintf('!!!!! The conversion from logger to transceiver time is not linear, file onset time discrepancy is %fms in logger time when it is %fms in transciever time.\n', File_timestamp_discrepancies_LogRef,File_timestamp_discrepancies_ms(File_i))
            end
            
            if abs(File_timestamp_discrepancies_ms(File_i))>0.5 % differences of 1 ms might be OK, because they could result from the millisecond resolution of the first time stamp after recording start
                disp(['File start time stamp read from event log and that calculated by samples differ by ' num2str((File_timestamp_discrepancies_ms(File_i))) ' ms...'])
                if File_timestamp_discrepancies_ms(File_i)>0
                    fprintf('The file started %d ms after what was expected given the number of samples of previous file and sample frequency\n', File_timestamp_discrepancies_ms(File_i));
                else
                    error(' Data overlap, the file started %d ms before what was expected given the number of samples of previous file and sample frequency\n', File_timestamp_discrepancies_ms(File_i));
                end
            end
            
            if strcmp(FileOnsetTime, 'logfile') || File_i==Ind_first_file % take the time stamp of the first sample of a .DAT file from the event log if the user specifies so, or if the current file is the first file after starting recording
                Timestamps_first_samples_usec(File_i)=File_start_timestamps(File_i)+Active_channels(active_channel_i)*ADC_sampling_period_usec_Logger; % time stamps of first sample of each of the channel; Jacob Vecht confirmed that the first sample of a file occurs at the file start time, unlike what was implied in the Neurologger manual (version 03-Apr-15 16:10:00)
            elseif strcmp(FileOnsetTime, 'cal') % calculate the time stamp of the first sample of a .DAT file by counting the number of samples since recording start and multiplying by the sampling period
                Timestamps_first_samples_usec(File_i)=File_timestamps_usec_from_sampling_period+Active_channels(active_channel_i)*ADC_sampling_period_usec_Logger;
            end
            
            % update the value for the index of the first file recorded after
            % an interruption in recording (if happened)
            if any(File_i==Ind_partial_files) && File_i~=Nfiles % if the current .DAT file is partially filled and recording resumed later
                Ind_first_file=File_i+1; % updated to be the file after the partially filled file
            end
            
            AD_count_channeli_all_files(Ind_firstNlast_samples(File_i,1):Ind_firstNlast_samples(File_i,2))=AD_count_data(1:(diff(Ind_firstNlast_samples(File_i,:))+1)); % the written data from the current .DAT file
        end
        
        % Check that the sample frequency of the transceiver was
        % approximately constant:
        if length(unique(Estimated_channelFS_Transceiver))>1
            disp('***** WARNING: The sample frequency in transceiver time was not constant******')
            disp('see plot of sample frequency for more details')
            Figure2=figure();
            title('variations of sample frequency and period along time')
            subplot(1,2,1)
            plot(Estimated_channelFS_Transceiver-nanmean(Estimated_channelFS_Transceiver))
            hold on
            plot(Estimated_channelFS_Logger-mean(Estimated_channelFS_Logger))
            hold on
            plot(Estimated_channelFS_Logger-FS)
            legend('Transceiver', 'Logger','Logger - advertised FS')
            ylabel('Sample frequency variations around the mean or expected value')
            xlabel('File #')
            text(Nfiles/2,0.0106, sprintf('Logger FS = 50,000Hz + %.3f',unique(Estimated_channelFS_Logger-FS)));
            
            subplot(1,2,2)
            plot(Estimated_channelT_Transceiver-nanmean(Estimated_channelT_Transceiver))
            hold on
            plot(Estimated_channelT_Logger-nanmean(Estimated_channelT_Logger))
            legend('Transceiver', 'Logger')
            ylabel('Period variations around the mean in microseconds')
            xlabel('File #')
        end
        
        if sum(Missing_files)~=Nfiles % if at least one .DAT file was processed
            disp('->Saving voltage traces in Matlab format')
            % delete the unwritten data points after checking that NANs are
            % where we are expecting them
            FirstNaN_local = find(isnan(AD_count_channeli_all_files),1,'first');
            if FirstNaN_local~=(Ind_firstNlast_samples(end,2)+1)
                error('Error of data allignment check code gathering data First Nan data in AD_count_all_channeli_all_files is %d when it is expected to be %d\n', find(isnan(AD_count_channeli_all_files),1,'first'), (Ind_firstNlast_samples(end,2)+1));
            end
            if sum(isnan(AD_count_channeli_all_files))~= (length(AD_count_channeli_all_files)-Ind_firstNlast_samples(end,2))
                error('Number of Nan values in AD_count_all_channeli_all_files is %d  when it is expected to be %d\n', sum(isnan(AD_count_channeli_all_files)), (length(AD_count_channeli_all_files)-Ind_firstNlast_samples(end,2)));
            end
            FirstNan(active_channel_i) = FirstNaN_local;
            
            AD_count_channeli_all_files(FirstNan(active_channel_i):end)=[]; % delete the unwritten samples
            
            % If Neural data, extract position of potential spike
            if strcmp(LoggerType(1:3), 'Mou') || strcmp(LoggerType(1:3), 'Rat') %#ok<PFBNS>
                Voltage_Trace = double(int16(AD_count_channeli_all_files))*ADC2uV_resolution;
                if sum(Missing_files)
                    [Peaks_positions, Filtered_voltage_trace]=detect_spikes(Voltage_Trace, nanmean(Estimated_channelFS_Transceiver), Ind_firstNlast_samples, 'MissingFiles',find(Missing_files));
                else
                    [Peaks_positions, Filtered_voltage_trace]=detect_spikes(Voltage_Trace, nanmean(Estimated_channelFS_Transceiver), Ind_firstNlast_samples);
                end
            end    
            
            
            % save the data
            Filename=fullfile(Output_folder, sprintf('%s_%s_CSC%d.mat', BatID, Date, Active_channels(active_channel_i))); % going with the following numbering convention: the first channel is channel 0, the second channel is channel 1, etc.
            OUTDAT = struct();
            OUTDAT.Bat_id = BatID;
            OUTDAT.Date = Date;
            OUTDAT.logger_serial_number = SerialNumber;
            OUTDAT.logger_type = LoggerType;
            OUTDAT.AD_count_int16=int16(AD_count_channeli_all_files); %data converted to signed 16-bit integers
            OUTDAT.Indices_of_first_and_last_samples=Ind_firstNlast_samples;
            OUTDAT.Estimated_channelFS_Transceiver = Estimated_channelFS_Transceiver; % Exact value of sample frequency for each file according to transceiver clock
            OUTDAT.Timestamps_of_first_samples_usec=Timestamps_first_samples_usec;
            OUTDAT.Samples_per_channel_per_file=Samples_per_channel_per_file(active_channel_i);
            OUTDAT.Sampling_period_usec_Logger=1e6/FS;
            OUTDAT.AD_count_to_uV_factor=ADC2uV_resolution;
            OUTDAT.indices_missing_data_files=find(Missing_files);
            OUTDAT.File_timestamp_discrepancies_ms=File_timestamp_discrepancies_ms;
            if strcmp(LoggerType(1:3), 'Mou') || strcmp(LoggerType(1:3), 'Rat')
                OUTDAT.Peaks_positions= Peaks_positions;
                OUTDAT.Filtered_voltage_trace= Filtered_voltage_trace;
            end
            parsave(Filename,OUTDAT)
            fprintf('Voltage trace of channel %d saved to %s\n', Active_channels(active_channel_i), Filename)
        end
        disp(['Files for which the start event time-stamp read from event log differ by 1 ms from the value obtained by calculation:  ' num2str(sum(abs(File_timestamp_discrepancies_ms)==1)) ' files...'])
        if sum(abs(File_timestamp_discrepancies_ms)>1)>1
            disp(['Files for which the start event time-stamp read from event log differ by more than 1 ms from the value obtained by calculation: ' num2str(sum(abs(File_timestamp_discrepancies_ms)>1)) ' files...'])
        end
        fprintf('Channel %d/%d: Data from %d out of %d .DAT files in %s were processed and saved.\n',active_channel_i,Nactive_channels,Nfiles-sum(Missing_files), Nfiles, Input_folder);
        if Save_param_figure
            saveas(Figure1,fullfile(Output_folder,sprintf('CD_correction%d.fig',Active_channels(active_channel_i))))
            saveas(Figure2,fullfile(Output_folder,sprintf('SampleFrequency%d.fig',Active_channels(active_channel_i))))
            close all
        end
%         clear OUTDAT AD_count_channeli_all_files Peaks_positions Filtered_voltage_trace
    end
    
    % check that all channels where stopped recording at the same sample
    FirstNan = unique(FirstNan);
    if length(FirstNan)>1
        disp('Indices of first unwriten values in all the AD_count_all_channeli_all_files')
        FirstNaN
        error('Error of data allignment, written data were not stopped at the same sample\n')
    end
    
    % If neural data, sort the potential spike arrival times on tetrode bundles to
    % only keep one 4 dimensional snippet per spike
    if strcmp(LoggerType(1:3), 'Mou') || strcmp(LoggerType(1:3), 'Rat')
        fprintf(1, '-> Neural logger: Extracting spike arrival times and spike snippets\n')
        % Loop through tetrodes and first combine, for each tetrode,
        % the potential spike positions detected on each electrode 
        fprintf(1, 'Combining potential spikes beloging to the same tetrode\n')
        Num_tetrodes = Num_channels/Num_EperBundle;
        Final_Peaks_positions = cell(Num_tetrodes,1);
        Num_peaks = nan(Num_tetrodes,1);
        for tt=1:Num_tetrodes
            % select the active channels for that bundle
            Active_channels_local = Active_channels(logical((Active_channels <(tt*Num_EperBundle)) .* (Active_channels >=((tt-1)*Num_EperBundle))));
            % load the peaks data in 2 cell arrays
            All_Peaks_positions = cell(length(Active_channels_local),1);
            All_Peaks_voltage = cell(length(Active_channels_local),1);
            for channel_i = 1:length(Active_channels_local)
                FileName=fullfile(Output_folder, sprintf('%s_%s_CSC%d.mat', BatID,Date, Active_channels_local(channel_i)));
                D=load(FileName, 'Peaks_positions');
                All_Peaks_positions{channel_i} = D.Peaks_positions;
                clear D
                D=load(FileName, 'Filtered_voltage_trace');
                All_Peaks_voltage{channel_i}= D.Filtered_voltage_trace(All_Peaks_positions{channel_i});
                clear D
            end
            % combine the peaks
           [Final_Peaks_positions{tt}]=combine_tetrode_spikes(All_Peaks_positions, All_Peaks_voltage);
           Num_peaks(tt) = length(Final_Peaks_positions{tt});
           clear All_Peaks_positions
           clear All_Peaks_voltage
        end
        
        % Now eliminate all potential spikes that are most likely noise.
        % Criteria: all threshold crossing peaks that are detected on all 4
        % tetrodes within a 50us window <-> FS*50^-6 samples
        fprintf(1, 'Eliminate noise peaks\n')
        D=load(FileName,'Estimated_channelFS_Transceiver');
        SampWinThresh = nanmean(D.Estimated_channelFS_Transceiver)*SpikeCollisionTolerance*10^-6;
        All_peaks_positions = cat(1,Final_Peaks_positions{:}); % The positions of all detected peak converted to a one dimensional vector
        All_peaks_tetrode = nan(sum(Num_peaks),1); % The Channel number on which the peaks are detected
        CumSum_peaks = [0; cumsum(Num_peaks)];
        Noisy_points = 0;
        for tt=1:Num_tetrodes
            All_peaks_tetrode(CumSum_peaks(tt) + (1:Num_peaks(tt))) = tt*ones(Num_peaks(tt),1);
        end
        [All_peaks_positions, I] = sort(All_peaks_positions); % Re-order the positions of detected peak in ascending order
        All_peaks_tetrode = All_peaks_tetrode(I); %Keep track of the tetrode number for each peak by appying the same ordering
        for pp=1:(sum(Num_peaks)-Num_EperBundle) % loop through each peak 
            if (All_peaks_positions(pp+3)<=(All_peaks_positions(pp)+SampWinThresh)) && sum(sort(All_peaks_tetrode(pp+(0:3)))' == 1:Num_EperBundle)==Num_EperBundle %find if the next 3 peaks are within the window and belonging to all other tetrodes
                Noisy_points = Noisy_points+1;
                for tt=1:Num_tetrodes
                    Final_Peaks_positions{All_peaks_tetrode(pp+tt-1)}(Final_Peaks_positions{All_peaks_tetrode(pp+tt-1)}==All_peaks_positions(pp+tt-1)) = [];
                end
            end
        end
        if Noisy_points>0
            fprintf('%d peaks were detected as being noise accross tetrodes and eliminated\n',Noisy_points);
        end
        
        % Extract and Save the snippets and spike arrival times
        fprintf(1, 'Translate peaks in spike arrival times and spike snippets\n')
        for tt=1:Num_tetrodes    
            % select the active channels for that bundle
            Active_channels_local = Active_channels(logical((Active_channels <(tt*Num_EperBundle)) .* (Active_channels >=((tt-1)*Num_EperBundle))));
            [Spike_arrival_times, Snippets] = extract_tetrode_snippets(Final_Peaks_positions{tt}, Output_folder, Active_channels_local); %#ok<ASGLU>
        
            % Save one file for each tetrode
            fprintf(1, 'Save spike arrival times and spike snippets\n')
            Filename_ST = fullfile(Output_folder,sprintf('%s_%s_Tetrode_spikes_time_T%d.mat',BatID, Date,tt));
            save(Filename_ST, 'Spike_arrival_times', 'Final_Peaks_positions', 'Date', 'BatID','SerialNumber');
            Filename_Snip = fullfile(Output_folder,sprintf('%s_%s_Tetrode_spikes_snippets_T%d.mat',BatID, Date,tt));
            save(Filename_Snip,'Snippets', 'Date', 'BatID','SerialNumber','-v7.3');
            fprintf(1,'Spike times and snippets of tetrode %d saved in\n%s\n and%s\n',tt,Filename_ST, Filename_Snip);
        end
    
        if NlxSave
            % If asked, also save for Neuralynx data analysis .ntt format (This
            % only works on windows machine...)
            mat2ntt(Output_folder);
        end
    end
    
end

%% Save the options and parameters that were used
if Save_param_figure
    Filename=fullfile(Output_folder,sprintf('%s_%s_extract_logger_data_parameters_%s.mat', BatID, Date, date));
    fprintf('Saving run parameters to %s\n', Filename)
    date_time_of_processing=datetime; % the date and time when this code was run
    clear OUT
    OUT.Date = Date;
    OUT.BatID = BatID;
    OUT.Input_folder=Input_folder;
    OUT.Output_folder=Output_folder;
    OUT.save_event_file=Save_event_file;
    OUT.save_voltage_AD_count_files=Save_voltage;
    OUT.Active_channels=Active_channels;
    OUT.Ref_channel=Ref_channel;
    OUT.Clock_difference_estimation=CD_Estimation;
    OUT.Timestamps_estimation=FileOnsetTime;
    OUT.Dat_rootname=Dat_rootname;
    OUT.num_channels=Num_channels;
    OUT.AD_count_for_zero_voltage=ADC_zero_voltage;
    OUT.AD_count_to_uV_factor=ADC2uV_resolution;
    OUT.FS=FS;
    if Save_voltage
        OUT.samples_per_channel_per_file=nan(Num_channels,1);
        OUT.samples_per_channel_per_file(Active_channels+1) = Samples_per_channel_per_file;
        OUT.ADC_data_format=ADC_data_format;
        OUT.ADC_unwritten_data_value=ADC_unwritten_data;
    end
    OUT.date_time_of_processing=date_time_of_processing;
    OUT.last_code_update=last_code_update; %#ok<STRNU>
    save(Filename,'-struct','OUT')
end
if Diary
    diary off
end
 end

 function parsave(Filename, Struct) %#ok<INUSD>
save(Filename,'-struct','Struct')
end
